{"version":3,"file":"vest.production.js","sources":["../../src/core/isolate/VestIsolateType.ts","../../src/core/isolate/IsolateSuite/IsolateSuite.ts","../../src/hooks/optional/OptionalTypes.ts","../../src/hooks/optional/Modes.ts","../../src/core/context/SuiteContext.ts","../../src/hooks/optional/optional.ts","../../src/errors/ErrorStrings.ts","../../src/core/StateMachines/CommonStateMachine.ts","../../src/core/StateMachines/IsolateTestStateMachine.ts","../../src/suiteResult/Severity.ts","../../src/hooks/focused/FocusedKeys.ts","../../src/core/isolate/VestIsolate.ts","../../src/core/isolate/IsolateTest/VestTest.ts","../../src/core/test/helpers/matchingFieldName.ts","../../src/core/isolate/IsolateTest/isSameProfileTest.ts","../../src/hooks/focused/focused.ts","../../src/suiteResult/SuiteResultTypes.ts","../../src/core/Runtime.ts","../../src/suiteResult/selectors/collectFailures.ts","../../src/suiteResult/selectors/suiteSelectors.ts","../../src/suiteResult/SummaryFailure.ts","../../src/core/isolate/IsolateTest/TestWalker.ts","../../src/suite/SuiteWalker.ts","../../src/core/test/helpers/matchingGroupName.ts","../../src/suiteResult/selectors/hasFailuresByTestObjects.ts","../../src/core/test/helpers/nonMatchingSeverityProfile.ts","../../src/suiteResult/selectors/shouldAddValidProperty.ts","../../src/suiteResult/selectors/useProduceSuiteSummary.ts","../../src/suiteResult/suiteResult.ts","../../src/suiteResult/selectors/LazyDraft.ts","../../src/isolates/skipWhen.ts","../../src/hooks/focused/useHasOnliedTests.ts","../../src/hooks/focused/useIsExcluded.ts","../../src/hooks/optional/mode.ts","../../src/isolates/omitWhen.ts","../../src/core/test/testLevelFlowControl/verifyTestRun.ts","../../src/core/isolate/IsolateTest/IsolateTestReconciler.ts","../../src/core/isolate/VestReconciler.ts","../../src/core/isolate/IsolateTest/cancelOverriddenPendingTest.ts","../../src/isolates/group.ts","../../src/hooks/include.ts","../../src/core/isolate/IsolateTest/IsolateTest.ts","../../src/core/test/testLevelFlowControl/runTest.ts","../../src/core/test/helpers/shouldUseErrorMessage.ts","../../src/core/test/test.ts","../../src/core/test/test.memo.ts","../../src/suite/getTypedMethods.ts","../../src/hooks/optional/omitOptionalFields.ts","../../src/core/VestBus/VestBus.ts","../../src/suite/runCallbacks.ts","../../src/suiteResult/suiteRunResult.ts","../../src/suiteResult/done/shouldSkipDoneRegistration.ts","../../src/suiteResult/done/deferDoneCallback.ts","../../src/suite/createSuite.ts","../../src/suite/validateParams/validateSuiteParams.ts","../../src/hooks/warn.ts","../../src/isolates/each.ts","../../src/core/isolate/IsolateEach/IsolateEach.ts"],"sourcesContent":["export const VestIsolateType = {\n  Each: 'Each',\n  Focused: 'Focused',\n  Group: 'Group',\n  OmitWhen: 'OmitWhen',\n  SkipWhen: 'SkipWhen',\n  Suite: 'Suite',\n  Test: 'Test',\n};\n","import { CB, assign } from 'vest-utils';\nimport { Isolate, TIsolate } from 'vestjs-runtime';\n\nimport { OptionalFieldDeclaration, OptionalFields } from 'OptionalTypes';\nimport { TFieldName } from 'SuiteResultTypes';\nimport { VestIsolateType } from 'VestIsolateType';\n\nexport type TIsolateSuite = TIsolate<{\n  optional: OptionalFields;\n}>;\n\nexport function IsolateSuite<Callback extends CB = CB>(\n  callback: Callback,\n): TIsolateSuite {\n  return Isolate.create(VestIsolateType.Suite, callback, {\n    optional: {},\n  });\n}\n\nexport class SuiteOptionalFields {\n  static setOptionalField(\n    suite: TIsolateSuite,\n    fieldName: TFieldName,\n    setter: (current: OptionalFieldDeclaration) => OptionalFieldDeclaration,\n  ): void {\n    const current = suite.data.optional;\n    const currentField = current[fieldName];\n\n    assign(current, {\n      [fieldName]: assign({}, currentField, setter(currentField)),\n    });\n  }\n\n  static getOptionalField(\n    suite: TIsolateSuite,\n    fieldName: TFieldName,\n  ): OptionalFieldDeclaration {\n    return SuiteOptionalFields.getOptionalFields(suite)[fieldName] ?? {};\n  }\n\n  static getOptionalFields(suite: TIsolateSuite): OptionalFields {\n    return suite.data?.optional ?? {};\n  }\n}\n","import { DynamicValue, OneOrMoreOf } from 'vest-utils';\n\nimport { TFieldName } from 'SuiteResultTypes';\n\nexport type OptionalFields = Record<string, OptionalFieldDeclaration>;\n\nexport type OptionalsInput<F extends TFieldName> =\n  | OneOrMoreOf<F>\n  | OptionalsObject<F>;\n\ntype OptionalsObject<F extends TFieldName> = Record<F, TOptionalRule | any>;\n\ntype ImmediateOptionalFieldDeclaration = {\n  type: OptionalFieldTypes.CUSTOM_LOGIC;\n  rule: TOptionalRule;\n  applied: boolean;\n};\n\ntype DelayedOptionalFieldDeclaration = {\n  type: OptionalFieldTypes.AUTO;\n  applied: boolean;\n  rule: null;\n};\n\ntype TOptionalRule = DynamicValue<boolean>;\n\nexport type OptionalFieldDeclaration =\n  | ImmediateOptionalFieldDeclaration\n  | DelayedOptionalFieldDeclaration;\n\nexport enum OptionalFieldTypes {\n  CUSTOM_LOGIC,\n  AUTO,\n}\n","export enum Modes {\n  EAGER = 'EAGER',\n  ALL = 'ALL',\n  ONE = 'ONE',\n}\n","import { createCascade } from 'context';\nimport {\n  assign,\n  TinyState,\n  tinyState,\n  cache,\n  CacheApi,\n  DynamicValue,\n} from 'vest-utils';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { Modes } from 'Modes';\n\nexport const SuiteContext = createCascade<CTXType>((ctxRef, parentContext) => {\n  if (parentContext) {\n    return null;\n  }\n\n  return assign(\n    {\n      inclusion: {},\n      mode: tinyState.createTinyState<Modes>(Modes.EAGER),\n      suiteParams: [],\n      testMemoCache,\n    },\n    ctxRef,\n  );\n});\n\ntype CTXType = {\n  inclusion: Record<string, DynamicValue<boolean>>;\n  mode: TinyState<Modes>;\n  suiteParams: any[];\n  testMemoCache: CacheApi<TIsolateTest>;\n  currentTest?: TIsolateTest;\n  groupName?: string;\n  skipped?: boolean;\n  omitted?: boolean;\n};\n\nexport function useCurrentTest(msg?: string) {\n  return SuiteContext.useX(msg).currentTest;\n}\n\nexport function useGroupName() {\n  return SuiteContext.useX().groupName;\n}\n\nexport function useInclusion() {\n  return SuiteContext.useX().inclusion;\n}\n\nexport function useMode() {\n  return SuiteContext.useX().mode();\n}\n\nexport function useSkipped() {\n  return SuiteContext.useX().skipped ?? false;\n}\n\nexport function useOmitted() {\n  return SuiteContext.useX().omitted ?? false;\n}\n\nconst testMemoCache = cache<TIsolateTest>(10);\n\nexport function useTestMemoCache() {\n  return SuiteContext.useX().testMemoCache;\n}\n\nexport function useSuiteParams() {\n  return SuiteContext.useX().suiteParams;\n}\n","import { enforce } from 'n4s';\nimport { isArray, isStringValue, asArray, hasOwnProperty } from 'vest-utils';\nimport { VestRuntime } from 'vestjs-runtime';\n\nimport { SuiteOptionalFields, TIsolateSuite } from 'IsolateSuite';\nimport { OptionalFieldTypes, OptionalsInput } from 'OptionalTypes';\nimport { useSuiteParams } from 'SuiteContext';\nimport { TFieldName } from 'SuiteResultTypes';\n\n// @vx-allow use-use\nexport function optional<F extends TFieldName>(\n  optionals: OptionalsInput<F>,\n): void {\n  const suiteRoot = VestRuntime.useAvailableRoot<TIsolateSuite>();\n\n  const suiteParams = useSuiteParams();\n  const dataObject = suiteParams?.[0] ?? {};\n\n  // There are two types of optional field declarations:\n\n  // 1 AUTO: Vest will automatically determine whether the field should be omitted\n  // Based on the current run. Vest will omit \"auto\" added fields without any\n  // configuration if their tests did not run at all in the suite, or if the data object\n  // contains a blank value for the field.\n  //\n  // 2 Custom logic: Vest will determine whether they should fail based on the custom\n  // logic supplied by the developer.\n  // If the developer supplies a function - when the function returns true, the field will be omitted.\n  // If the developer supplies a boolean - the field will be omitted if the value is true.\n  // If the developer supplies a value - the field will be omitted if the value is blank.\n\n  // AUTO case (field name)\n  if (isArray(optionals) || isStringValue(optionals)) {\n    asArray(optionals).forEach(optionalField => {\n      SuiteOptionalFields.setOptionalField(suiteRoot, optionalField, () => ({\n        type: OptionalFieldTypes.AUTO,\n        applied: hasOwnProperty(dataObject, optionalField)\n          ? enforce.isBlank().test(dataObject?.[optionalField])\n          : false,\n        rule: null,\n      }));\n    });\n  } else {\n    // CUSTOM_LOGIC case (function or boolean)\n    for (const field in optionals) {\n      const value = optionals[field];\n\n      SuiteOptionalFields.setOptionalField(suiteRoot, field, () => ({\n        type: OptionalFieldTypes.CUSTOM_LOGIC,\n        rule: value,\n        applied: enforce.isBlank().test(value) || value === true,\n      }));\n    }\n  }\n}\n\nexport function useIsOptionalFieldApplied(fieldName?: TFieldName) {\n  if (!fieldName) {\n    return false;\n  }\n\n  const root = VestRuntime.useAvailableRoot<TIsolateSuite>();\n\n  return (\n    SuiteOptionalFields.getOptionalField(root, fieldName)?.applied ?? false\n  );\n}\n","export enum ErrorStrings {\n  HOOK_CALLED_OUTSIDE = 'hook called outside of a running suite.',\n  EXPECTED_VEST_TEST = 'Expected value to be an instance of IsolateTest',\n  FIELD_NAME_REQUIRED = 'Field name must be passed',\n  SUITE_MUST_BE_INITIALIZED_WITH_FUNCTION = 'Suite must be initialized with a function',\n  PROMISIFY_REQUIRE_FUNCTION = 'Vest.Promisify must be called with a function',\n  PARSER_EXPECT_RESULT_OBJECT = \"Vest parser: expected argument at position 0 to be Vest's result object.\",\n  WARN_MUST_BE_CALLED_FROM_TEST = 'Warn must be called from within the body of a test function',\n  EACH_CALLBACK_MUST_BE_A_FUNCTION = 'Each must be called with a function',\n  INVALID_PARAM_PASSED_TO_FUNCTION = 'Incompatible params passed to {fn_name} function. \"{param}\" must be of type {expected}',\n  TESTS_CALLED_IN_DIFFERENT_ORDER = `Vest Critical Error: Tests called in different order than previous run.\n    expected: {fieldName}\n    received: {prevName}\n    This can happen on one of two reasons:\n    1. You're using if/else statements to conditionally select tests. Instead, use \"skipWhen\".\n    2. You are iterating over a list of tests, and their order changed. Use \"each\" and a custom key prop so that Vest retains their state.`,\n  UNEXPECTED_TEST_REGISTRATION_ERROR = `Unexpected error encountered during test registration.\n      Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.\n      Error: {error}.`,\n  UNEXPECTED_TEST_RUN_ERROR = `Unexpected error encountered during test run. Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.`,\n  INCLUDE_SELF = 'Trying to call include.when on the same field.',\n}\n","import { StateMachine, TStateMachine, ValueOf } from 'vest-utils';\n\nexport const CommonStates = {\n  PENDING: 'PENDING',\n  INITIAL: 'INITIAL',\n  DONE: 'DONE',\n};\n\nconst State = {\n  [CommonStates.PENDING]: CommonStates.PENDING,\n  [CommonStates.INITIAL]: CommonStates.INITIAL,\n  [CommonStates.DONE]: CommonStates.DONE,\n};\n\nexport type State = ValueOf<typeof State>;\n\nconst machine: TStateMachine<State> = {\n  initial: State.INITIAL,\n  states: {\n    [State.DONE]: {},\n    [State.INITIAL]: {\n      [State.PENDING]: State.PENDING,\n      [State.DONE]: State.DONE,\n    },\n    [State.PENDING]: {\n      [State.DONE]: State.DONE,\n    },\n  },\n};\n\nexport const CommonStateMachine = StateMachine<State>(machine);\n","import { StateMachine, TStateMachine, ValueOf } from 'vest-utils';\n\nimport { CommonStates } from 'CommonStateMachine';\n\nexport const TestStatus = {\n  [CommonStates.PENDING]: CommonStates.PENDING,\n  CANCELED: 'CANCELED',\n  FAILED: 'FAILED',\n  OMITTED: 'OMITTED',\n  PASSING: 'PASSING',\n  SKIPPED: 'SKIPPED',\n  UNTESTED: 'UNTESTED',\n  WARNING: 'WARNING',\n};\n\nexport const TestAction = {\n  RESET: 'RESET',\n};\n\nexport type TestStatus = ValueOf<typeof TestStatus>;\nexport type TestAction = ValueOf<typeof TestAction>;\n\nexport type TestStateMachineAction = TestAction | TestStatus;\n\nconst machine: TStateMachine<TestStatus, TestStateMachineAction> = {\n  initial: TestStatus.UNTESTED,\n  states: {\n    '*': {\n      [TestStatus.OMITTED]: TestStatus.OMITTED,\n      [TestAction.RESET]: TestStatus.UNTESTED,\n    },\n    [TestStatus.UNTESTED]: {\n      [TestStatus.CANCELED]: TestStatus.CANCELED,\n      [TestStatus.FAILED]: TestStatus.FAILED,\n\n      [TestStatus.PASSING]: TestStatus.PASSING,\n      [TestStatus.PENDING]: TestStatus.PENDING,\n      [TestStatus.SKIPPED]: TestStatus.SKIPPED,\n      [TestStatus.WARNING]: TestStatus.WARNING,\n    },\n    [TestStatus.PENDING]: {\n      [TestStatus.CANCELED]: TestStatus.CANCELED,\n      [TestStatus.FAILED]: TestStatus.FAILED,\n\n      [TestStatus.PASSING]: TestStatus.PASSING,\n      [TestStatus.SKIPPED]: [\n        TestStatus.SKIPPED,\n        (force?: boolean) => force === true,\n      ],\n      [TestStatus.WARNING]: TestStatus.WARNING,\n    },\n    [TestStatus.SKIPPED]: {},\n    [TestStatus.FAILED]: {},\n    [TestStatus.WARNING]: {},\n    [TestStatus.PASSING]: {},\n    [TestStatus.CANCELED]: {},\n    [TestStatus.OMITTED]: {},\n  },\n};\n\nexport const IsolateTestStateMachine = StateMachine<\n  TestStatus,\n  TestStateMachineAction\n>(machine);\n","export enum Severity {\n  WARNINGS = 'warnings',\n  ERRORS = 'errors',\n}\n\nexport enum SeverityCount {\n  ERROR_COUNT = 'errorCount',\n  WARN_COUNT = 'warnCount',\n}\n\nexport function countKeyBySeverity(severity: Severity): SeverityCount {\n  return severity === Severity.ERRORS\n    ? SeverityCount.ERROR_COUNT\n    : SeverityCount.WARN_COUNT;\n}\n\nexport enum TestSeverity {\n  Error = 'error',\n  Warning = 'warning',\n}\n","export enum FocusModes {\n  ONLY,\n  SKIP,\n}\n","import { TStateMachineApi } from 'vest-utils';\nimport { TIsolate } from 'vestjs-runtime';\n\nimport { CommonStateMachine, CommonStates } from 'CommonStateMachine';\n\nexport class VestIsolate {\n  static stateMachine: TStateMachineApi = CommonStateMachine;\n\n  static getStatus(isolate: TIsolate): string {\n    return isolate.status ?? CommonStates.INITIAL;\n  }\n\n  static setStatus(isolate: TIsolate, status: string, payload?: any): void {\n    isolate.status = this.stateMachine.staticTransition(\n      VestIsolate.getStatus(isolate),\n      status,\n      payload,\n    );\n  }\n\n  static statusEquals(isolate: TIsolate, status: string): boolean {\n    return VestIsolate.getStatus(isolate) === status;\n  }\n\n  static setPending(isolate: TIsolate): void {\n    this.setStatus(isolate, CommonStates.PENDING);\n  }\n\n  static setDone(isolate: TIsolate): void {\n    this.setStatus(isolate, CommonStates.DONE);\n  }\n\n  static isPending(isolate: TIsolate): boolean {\n    return VestIsolate.statusEquals(isolate, CommonStates.PENDING);\n  }\n}\n","import { Maybe, invariant, isPromise, optionalFunctionValue } from 'vest-utils';\nimport { IsolateMutator, IsolateSelectors, TIsolate } from 'vestjs-runtime';\n\nimport { ErrorStrings } from 'ErrorStrings';\nimport type { TIsolateTest } from 'IsolateTest';\nimport {\n  IsolateTestStateMachine,\n  TestAction,\n  TestStatus,\n} from 'IsolateTestStateMachine';\nimport { TestSeverity } from 'Severity';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { VestIsolate } from 'VestIsolate';\nimport { VestIsolateType } from 'VestIsolateType';\n\nexport class VestTest extends VestIsolate {\n  static stateMachine = IsolateTestStateMachine;\n\n  // Read\n\n  static getData<\n    F extends TFieldName = TFieldName,\n    G extends TGroupName = TGroupName,\n  >(test: TIsolateTest<F, G>) {\n    invariant(test.data);\n    return test.data;\n  }\n\n  static is(isolate?: Maybe<TIsolate>): isolate is TIsolateTest {\n    return IsolateSelectors.isIsolateType<TIsolateTest>(\n      isolate,\n      VestIsolateType.Test,\n    );\n  }\n\n  static isX(isolate?: Maybe<TIsolate>): asserts isolate is TIsolateTest {\n    invariant(VestTest.is(isolate), ErrorStrings.EXPECTED_VEST_TEST);\n  }\n\n  static cast<F extends TFieldName = string, G extends TGroupName = string>(\n    isolate?: Maybe<TIsolate>,\n  ): TIsolateTest<F, G> {\n    VestTest.isX(isolate);\n    return isolate as TIsolateTest<F, G>;\n  }\n\n  static warns(test: TIsolateTest): boolean {\n    return VestTest.getData(test).severity === TestSeverity.Warning;\n  }\n\n  static isOmitted(test: TIsolateTest): boolean {\n    return VestTest.statusEquals(test, TestStatus.OMITTED);\n  }\n\n  static isUntested(test: TIsolateTest): boolean {\n    return VestTest.statusEquals(test, TestStatus.UNTESTED);\n  }\n\n  static isFailing(test: TIsolateTest): boolean {\n    return VestTest.statusEquals(test, TestStatus.FAILED);\n  }\n\n  static isCanceled(test: TIsolateTest): boolean {\n    return VestTest.statusEquals(test, TestStatus.CANCELED);\n  }\n\n  static isSkipped(test: TIsolateTest): boolean {\n    return VestTest.statusEquals(test, TestStatus.SKIPPED);\n  }\n\n  static isPassing(test: TIsolateTest): boolean {\n    return VestTest.statusEquals(test, TestStatus.PASSING);\n  }\n\n  static isWarning(test: TIsolateTest): boolean {\n    return VestTest.statusEquals(test, TestStatus.WARNING);\n  }\n\n  static hasFailures(test: TIsolateTest): boolean {\n    return VestTest.isFailing(test) || VestTest.isWarning(test);\n  }\n\n  static isNonActionable(test: TIsolateTest): boolean {\n    return (\n      VestTest.isSkipped(test) ||\n      VestTest.isOmitted(test) ||\n      VestTest.isCanceled(test)\n    );\n  }\n\n  static isTested(test: TIsolateTest): boolean {\n    return VestTest.hasFailures(test) || VestTest.isPassing(test);\n  }\n\n  static awaitsResolution(test: TIsolateTest): boolean {\n    // Is the test in a state where it can still be run, or complete running\n    // and its final status is indeterminate?\n    return (\n      VestTest.isSkipped(test) ||\n      VestTest.isUntested(test) ||\n      VestTest.isPending(test)\n    );\n  }\n\n  static isAsyncTest(test: TIsolateTest): boolean {\n    return isPromise(VestTest.getData(test).asyncTest);\n  }\n\n  // Mutate\n\n  // static setPending(test: TIsolateTest) {\n  //   this.setStatus(test, TestStatus.PENDING);\n  // }\n\n  static fail(test: TIsolateTest): void {\n    VestTest.setStatus(\n      test,\n      VestTest.warns(test) ? TestStatus.WARNING : TestStatus.FAILED,\n    );\n  }\n\n  static pass(test: TIsolateTest): void {\n    VestTest.setStatus(test, TestStatus.PASSING);\n  }\n\n  static warn(test: TIsolateTest): void {\n    VestTest.setData(test, current => ({\n      ...current,\n      severity: TestSeverity.Warning,\n    }));\n  }\n\n  static setData(\n    test: TIsolateTest,\n    setter:\n      | ((current: TIsolateTest['data']) => TIsolateTest['data'])\n      | TIsolateTest['data'],\n  ): void {\n    test.data = optionalFunctionValue(setter, VestTest.getData(test));\n  }\n\n  static skip(test: TIsolateTest, force?: boolean): void {\n    // Without this force flag, the test will be marked as skipped even if it is pending.\n    // This means that it will not be counted in \"allIncomplete\" and its done callbacks\n    // will not be called, or will be called prematurely.\n    // What this mostly say is that when we have a pending test for one field, and we then\n    // start typing in a different field - the pending test will be canceled, which\n    // is usually an unwanted behavior.\n    // The only scenario in which we DO want to cancel the async test regardless\n    // is when we specifically skip a test with `skipWhen`, which is handled by the\n    // \"force\" boolean flag.\n    // I am not a fan of this flag, but it gets the job done.\n    VestTest.setStatus(test, TestStatus.SKIPPED, force);\n  }\n\n  static cancel(test: TIsolateTest): void {\n    VestTest.setStatus(test, TestStatus.CANCELED);\n    IsolateMutator.abort(test, TestStatus.CANCELED);\n  }\n\n  static omit(test: TIsolateTest): void {\n    VestTest.setStatus(test, TestStatus.OMITTED);\n  }\n\n  static reset(test: TIsolateTest): void {\n    VestTest.setStatus(test, TestAction.RESET);\n  }\n}\n","import { Maybe } from 'vest-utils';\n\nimport { TFieldName } from 'SuiteResultTypes';\nimport { WithFieldName } from 'TestTypes';\n\nexport function nonMatchingFieldName(\n  WithFieldName: WithFieldName<TFieldName>,\n  fieldName?: Maybe<TFieldName>,\n): boolean {\n  return !!fieldName && !matchingFieldName(WithFieldName, fieldName);\n}\n\nexport default function matchingFieldName(\n  WithFieldName: WithFieldName<TFieldName>,\n  fieldName?: Maybe<TFieldName>,\n): boolean {\n  return !!(fieldName && WithFieldName.fieldName === fieldName);\n}\n\nexport function matchesOrHasNoFieldName(\n  WithFieldName: WithFieldName<TFieldName>,\n  fieldName?: Maybe<TFieldName>,\n): boolean {\n  if (fieldName) {\n    return matchingFieldName(WithFieldName, fieldName);\n  }\n  return true;\n}\n","import { TIsolateTest } from 'IsolateTest';\nimport { VestTest } from 'VestTest';\nimport matchingFieldName from 'matchingFieldName';\n\nexport function isSameProfileTest(\n  testObject1: TIsolateTest,\n  testObject2: TIsolateTest,\n): boolean {\n  const { groupName: gn1 } = VestTest.getData(testObject1);\n  const { groupName: gn2, fieldName: fn2 } = VestTest.getData(testObject2);\n  return (\n    matchingFieldName(VestTest.getData(testObject1), fn2) &&\n    gn1 === gn2 &&\n    // Specifically using == here. The reason is that when serializing\n    // suite result, empty key gets removed, but it can also be null.\n    testObject1.key == testObject2.key\n  );\n}\n","import {\n  asArray,\n  Maybe,\n  OneOrMoreOf,\n  noop,\n  Nullable,\n  isNotEmpty,\n  isStringValue,\n} from 'vest-utils';\nimport { IsolateSelectors, TIsolate, Isolate } from 'vestjs-runtime';\n\nimport { FocusModes } from 'FocusedKeys';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { VestIsolateType } from 'VestIsolateType';\n\nexport type ExclusionItem = Maybe<OneOrMoreOf<string>>;\nexport type FieldExclusion<F extends TFieldName> = Maybe<OneOrMoreOf<F>>;\nexport type GroupExclusion<G extends TGroupName> = Maybe<OneOrMoreOf<G>>;\n\nexport type TIsolateFocused = TIsolate<IsolateFocusedPayload>;\n\nexport type IsolateFocusedPayload = {\n  focusMode: FocusModes;\n  match: FieldExclusion<TFieldName>;\n  matchAll: boolean;\n};\n\nexport function IsolateFocused(\n  focusMode: FocusModes,\n  match?: true | FieldExclusion<TFieldName>,\n): TIsolateFocused {\n  return Isolate.create(VestIsolateType.Focused, noop, {\n    focusMode,\n    match: asArray(match).filter(isStringValue),\n    matchAll: match === true,\n  });\n}\n\nexport class FocusSelectors {\n  static isSkipFocused(\n    focus: Nullable<TIsolateFocused>,\n    fieldName?: TFieldName,\n  ): boolean {\n    return (\n      focus?.data.focusMode === FocusModes.SKIP &&\n      (hasFocus(focus, fieldName) || focus.data.matchAll === true)\n    );\n  }\n  static isOnlyFocused(\n    focus: Nullable<TIsolateFocused>,\n    fieldName?: TFieldName,\n  ): boolean {\n    return (\n      focus?.data.focusMode === FocusModes.ONLY && hasFocus(focus, fieldName)\n    );\n  }\n\n  static isIsolateFocused(isolate: TIsolate): isolate is TIsolateFocused {\n    return IsolateSelectors.isIsolateType(isolate, VestIsolateType.Focused);\n  }\n}\n\n/**\n * Adds a field or a list of fields into the inclusion list\n *\n * @example\n *\n * only('username');\n */\n// @vx-allow use-use\nexport function only(match: FieldExclusion<TFieldName> | false) {\n  return IsolateFocused(FocusModes.ONLY, defaultMatch(match));\n}\n/**\n * Adds a field or a list of fields into the exclusion list\n *\n * @example\n *\n * skip('username');\n */\n// @vx-allow use-use\nexport function skip(match: FieldExclusion<TFieldName> | boolean) {\n  return IsolateFocused(FocusModes.SKIP, defaultMatch(match));\n}\n\nfunction defaultMatch(match: FieldExclusion<TFieldName> | boolean) {\n  return match === false ? [] : match;\n}\n\nfunction hasFocus(focus: Nullable<TIsolateFocused>, fieldName?: TFieldName) {\n  return (\n    isNotEmpty(focus?.data.match) &&\n    (fieldName ? focus?.data.match?.includes(fieldName) ?? true : true)\n  );\n}\n","import { Maybe, Nullable } from 'vest-utils';\n\nimport { Severity } from 'Severity';\nimport { SummaryFailure } from 'SummaryFailure';\nimport { Done } from 'suiteRunResult';\nimport { SuiteSelectors } from 'suiteSelectors';\n\nexport class SummaryBase {\n  public errorCount = 0;\n  public warnCount = 0;\n  public testCount = 0;\n  public pendingCount = 0;\n}\n\nexport class SuiteSummary<\n  F extends TFieldName,\n  G extends TGroupName,\n> extends SummaryBase {\n  public [Severity.ERRORS]: SummaryFailure<F, G>[] = [];\n  public [Severity.WARNINGS]: SummaryFailure<F, G>[] = [];\n  public groups: Groups<G, F> = {} as Groups<G, F>;\n  public tests: Tests<F> = {} as Tests<F>;\n  public valid: Nullable<boolean> = null;\n}\n\nexport type TestsContainer<F extends TFieldName, G extends TGroupName> =\n  | Group<G>\n  | Tests<F>;\nexport type GroupTestSummary = SingleTestSummary;\n\nexport type Groups<G extends TGroupName, F extends TFieldName> = Record<\n  G,\n  Group<F>\n>;\nexport type Group<F extends TFieldName> = Record<F, GroupTestSummary>;\nexport type Tests<F extends TFieldName> = Record<F, SingleTestSummary>;\n\nexport type SingleTestSummary = SummaryBase & {\n  errors: string[];\n  warnings: string[];\n  valid: Nullable<boolean>;\n  pendingCount: number;\n};\n\nexport type GetFailuresResponse = FailureMessages | string[];\n\nexport type FailureMessages = Record<string, string[]>;\n\nexport type SuiteResult<\n  F extends TFieldName,\n  G extends TGroupName,\n> = SuiteSummary<F, G> & SuiteSelectors<F, G> & { suiteName: SuiteName };\n\nexport type SuiteRunResult<\n  F extends TFieldName,\n  G extends TGroupName,\n> = SuiteResult<F, G> & {\n  done: Done<F, G>;\n};\n\nexport type SuiteName = Maybe<string>;\n\nexport type TFieldName<T extends string = string> = T;\nexport type TGroupName<G extends string = string> = G;\n","import {\n  CB,\n  CacheApi,\n  Maybe,\n  TinyState,\n  cache,\n  seq,\n  tinyState,\n} from 'vest-utils';\nimport { IRecociler, TIsolate, VestRuntime } from 'vestjs-runtime';\n\nimport { TIsolateSuite } from 'IsolateSuite';\nimport { Severity } from 'Severity';\nimport {\n  SuiteName,\n  SuiteResult,\n  TFieldName,\n  TGroupName,\n} from 'SuiteResultTypes';\n\nexport type DoneCallback = (res: SuiteResult<TFieldName, TGroupName>) => void;\ntype FieldCallbacks = Record<string, DoneCallbacks>;\ntype DoneCallbacks = Array<DoneCallback>;\ntype FailuresCache = {\n  [Severity.ERRORS]: Record<TFieldName, TIsolate[]>;\n  [Severity.WARNINGS]: Record<TFieldName, TIsolate[]>;\n};\nexport type PreAggCache = {\n  pending: TIsolate[];\n  failures: FailuresCache;\n};\n\ntype StateExtra = {\n  doneCallbacks: TinyState<DoneCallbacks>;\n  fieldCallbacks: TinyState<FieldCallbacks>;\n  suiteName: Maybe<string>;\n  suiteId: string;\n  suiteResultCache: CacheApi<SuiteResult<TFieldName, TGroupName>>;\n  preAggCache: CacheApi<PreAggCache>;\n};\nconst suiteResultCache = cache<SuiteResult<TFieldName, TGroupName>>();\nconst preAggCache = cache<PreAggCache>();\n\nexport function useCreateVestState({\n  suiteName,\n  VestReconciler,\n}: {\n  suiteName?: SuiteName;\n  VestReconciler: IRecociler;\n}) {\n  const stateRef: StateExtra = {\n    doneCallbacks: tinyState.createTinyState<DoneCallbacks>(() => []),\n    fieldCallbacks: tinyState.createTinyState<FieldCallbacks>(() => ({})),\n    preAggCache,\n    suiteId: seq(),\n    suiteName,\n    suiteResultCache,\n  };\n\n  return VestRuntime.createRef(VestReconciler, stateRef);\n}\n\nfunction useX() {\n  return VestRuntime.useXAppData<StateExtra>();\n}\n\nexport function useDoneCallbacks() {\n  return useX().doneCallbacks();\n}\n\nexport function useFieldCallbacks() {\n  return useX().fieldCallbacks();\n}\n\nexport function useSuiteName() {\n  return useX().suiteName;\n}\n\nexport function useSuiteId() {\n  return useX().suiteId;\n}\n\nexport function useSuiteResultCache<F extends TFieldName, G extends TGroupName>(\n  action: CB<SuiteResult<F, G>>,\n): SuiteResult<F, G> {\n  const suiteResultCache = useX().suiteResultCache;\n\n  return suiteResultCache([useSuiteId()], action) as SuiteResult<F, G>;\n}\n\nexport function usePreAggCache(action: CB<PreAggCache>) {\n  const preAggCache = useX().preAggCache;\n\n  return preAggCache([useSuiteId()], action);\n}\n\nexport function useExpireSuiteResultCache() {\n  const suiteResultCache = useX().suiteResultCache;\n  suiteResultCache.invalidate([useSuiteId()]);\n\n  // whenever we invalidate the entire result, we also want to invalidate the preagg cache\n  // so that we do not get stale results there.\n  // there may be a better place to do this, but for now, this should work.\n  preAggCache.invalidate([useSuiteId()]);\n}\n\nexport function useResetCallbacks() {\n  const [, , resetDoneCallbacks] = useDoneCallbacks();\n  const [, , resetFieldCallbacks] = useFieldCallbacks();\n\n  resetDoneCallbacks();\n  resetFieldCallbacks();\n}\n\nexport function useResetSuite() {\n  useResetCallbacks();\n  VestRuntime.reset();\n}\n\nexport function useLoadSuite(rootNode: TIsolateSuite): void {\n  VestRuntime.useSetHistoryRoot(rootNode);\n  useExpireSuiteResultCache();\n}\n","import { isPositive } from 'vest-utils';\n\nimport { countKeyBySeverity, Severity } from 'Severity';\nimport {\n  FailureMessages,\n  TestsContainer,\n  TFieldName,\n  TGroupName,\n} from 'SuiteResultTypes';\n\n// calls collectAll or getByFieldName depending on whether fieldName is provided\n\nexport function gatherFailures(\n  testGroup: TestsContainer<TFieldName, TGroupName>,\n  severityKey: Severity,\n  fieldName?: TFieldName,\n): string[] | FailureMessages {\n  return fieldName\n    ? getByFieldName(testGroup, severityKey, fieldName)\n    : collectAll(testGroup, severityKey);\n}\n\nfunction getByFieldName(\n  testGroup: TestsContainer<TFieldName, TGroupName>,\n  severityKey: Severity,\n  fieldName: TFieldName,\n): string[] {\n  return testGroup?.[fieldName]?.[severityKey] || [];\n}\n\nfunction collectAll(\n  testGroup: TestsContainer<TFieldName, TGroupName>,\n  severityKey: Severity,\n): FailureMessages {\n  const output: FailureMessages = {};\n\n  const countKey = countKeyBySeverity(severityKey);\n\n  for (const field in testGroup) {\n    if (isPositive(testGroup[field][countKey])) {\n      // We will probably never get to the fallback array\n      // leaving it just in case the implementation changes\n      output[field] = testGroup[field][severityKey] || [];\n    }\n  }\n\n  return output;\n}\n","import { Maybe, greaterThan, isPositive } from 'vest-utils';\n\nimport { Severity, SeverityCount } from 'Severity';\nimport {\n  FailureMessages,\n  GetFailuresResponse,\n  SuiteResult,\n  SuiteSummary,\n  TFieldName,\n  TGroupName,\n  TestsContainer,\n} from 'SuiteResultTypes';\nimport { SummaryFailure } from 'SummaryFailure';\nimport { gatherFailures } from 'collectFailures';\nimport matchingFieldName from 'matchingFieldName';\n\nexport function bindSuiteSelectors<F extends TFieldName, G extends TGroupName>(\n  get: <F extends string, G extends string>() => SuiteResult<F, G>,\n): SuiteSelectors<F, G> {\n  return {\n    getError: (...args: Parameters<SuiteSelectors<F, G>['getError']>) =>\n      get().getError(...args),\n    getErrors: (...args: Parameters<SuiteSelectors<F, G>['getErrors']>) =>\n      get().getErrors(...args),\n    getErrorsByGroup: (\n      ...args: Parameters<SuiteSelectors<F, G>['getErrorsByGroup']>\n    ) => get().getErrorsByGroup(...args),\n    getMessage: (...args: Parameters<SuiteSelectors<F, G>['getMessage']>) =>\n      get().getMessage(...args),\n    getWarning: (...args: Parameters<SuiteSelectors<F, G>['getWarning']>) =>\n      get().getWarning(...args),\n    getWarnings: (...args: Parameters<SuiteSelectors<F, G>['getWarnings']>) =>\n      get().getWarnings(...args),\n    getWarningsByGroup: (\n      ...args: Parameters<SuiteSelectors<F, G>['getWarningsByGroup']>\n    ) => get().getWarningsByGroup(...args),\n    hasErrors: (...args: Parameters<SuiteSelectors<F, G>['hasErrors']>) =>\n      get().hasErrors(...args),\n    hasErrorsByGroup: (\n      ...args: Parameters<SuiteSelectors<F, G>['hasErrorsByGroup']>\n    ) => get().hasErrorsByGroup(...args),\n    hasWarnings: (...args: Parameters<SuiteSelectors<F, G>['hasWarnings']>) =>\n      get().hasWarnings(...args),\n    hasWarningsByGroup: (\n      ...args: Parameters<SuiteSelectors<F, G>['hasWarningsByGroup']>\n    ) => get().hasWarningsByGroup(...args),\n    isPending: (...args: Parameters<SuiteSelectors<F, G>['isPending']>) => {\n      return get().isPending(...args);\n    },\n    isTested: (...args: Parameters<SuiteSelectors<F, G>['isTested']>) =>\n      get().isTested(...args),\n    isValid: (...args: Parameters<SuiteSelectors<F, G>['isValid']>) =>\n      get().isValid(...args),\n    isValidByGroup: (\n      ...args: Parameters<SuiteSelectors<F, G>['isValidByGroup']>\n    ) => get().isValidByGroup(...args),\n  } as SuiteSelectors<F, G>;\n}\n\n// eslint-disable-next-line max-lines-per-function, max-statements\nexport function suiteSelectors<F extends TFieldName, G extends TGroupName>(\n  summary: SuiteSummary<F, G>,\n): SuiteSelectors<F, G> {\n  const selectors = {\n    getError,\n    getErrors,\n    getErrorsByGroup,\n    getMessage,\n    getWarning,\n    getWarnings,\n    getWarningsByGroup,\n    hasErrors,\n    hasErrorsByGroup,\n    hasWarnings,\n    hasWarningsByGroup,\n    isPending,\n    isTested,\n    isValid,\n    isValidByGroup,\n  };\n\n  return selectors;\n\n  // Booleans\n\n  function isValid(fieldName?: F): boolean {\n    return Boolean(fieldName ? summary.tests[fieldName]?.valid : summary.valid);\n  }\n\n  function isValidByGroup(groupName: G, fieldName?: F): boolean {\n    const group = summary.groups[groupName];\n\n    if (!group) {\n      return false;\n    }\n\n    if (fieldName) {\n      return isFieldValid(group, fieldName);\n    }\n    for (const fieldName in group) {\n      if (!isFieldValid(group, fieldName)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function hasWarnings(fieldName?: F): boolean {\n    return hasFailures(summary, SeverityCount.WARN_COUNT, fieldName);\n  }\n\n  function hasErrors(fieldName?: F): boolean {\n    return hasFailures(summary, SeverityCount.ERROR_COUNT, fieldName);\n  }\n\n  function isTested(fieldName: F): boolean {\n    return isPositive(summary.tests[fieldName]?.testCount);\n  }\n\n  function hasWarningsByGroup<G extends TGroupName>(\n    groupName: G,\n    fieldName?: F,\n  ): boolean {\n    return hasFailuresByGroup(\n      summary,\n      SeverityCount.WARN_COUNT,\n      groupName,\n      fieldName,\n    );\n  }\n\n  function hasErrorsByGroup<G extends TGroupName>(\n    groupName: G,\n    fieldName?: F,\n  ): boolean {\n    return hasFailuresByGroup(\n      summary,\n      SeverityCount.ERROR_COUNT,\n      groupName,\n      fieldName,\n    );\n  }\n\n  // Responses\n\n  function getWarnings(): FailureMessages;\n  function getWarnings(fieldName: F): string[];\n  function getWarnings(fieldName?: F): GetFailuresResponse {\n    return getFailures(summary, Severity.WARNINGS, fieldName);\n  }\n\n  function getWarning(): Maybe<SummaryFailure<F, G>>;\n  function getWarning(fieldName: F): Maybe<string>;\n  function getWarning(fieldName?: F): Maybe<SummaryFailure<F, G> | string> {\n    return getFailure<F, G>(Severity.WARNINGS, summary, fieldName as F);\n  }\n\n  function getErrors(): FailureMessages;\n  function getErrors(fieldName: F): string[];\n  function getErrors(fieldName?: F): GetFailuresResponse {\n    return getFailures(summary, Severity.ERRORS, fieldName);\n  }\n\n  function getError(): Maybe<SummaryFailure<F, G>>;\n  function getError(fieldName: F): Maybe<string>;\n  function getError(fieldName?: F): Maybe<SummaryFailure<F, G> | string> {\n    return getFailure<F, G>(Severity.ERRORS, summary, fieldName as F);\n  }\n\n  function getErrorsByGroup(groupName: G): FailureMessages;\n  function getErrorsByGroup(groupName: G, fieldName: F): string[];\n  function getErrorsByGroup(groupName: G, fieldName?: F): GetFailuresResponse {\n    return getFailuresByGroup(summary, Severity.ERRORS, groupName, fieldName);\n  }\n\n  function getMessage(fieldName: F): Maybe<string> {\n    return getError(fieldName) || getWarning(fieldName);\n  }\n\n  function getWarningsByGroup(groupName: G): FailureMessages;\n  function getWarningsByGroup(groupName: G, fieldName: F): string[];\n  function getWarningsByGroup(\n    groupName: G,\n    fieldName?: F,\n  ): GetFailuresResponse {\n    return getFailuresByGroup(summary, Severity.WARNINGS, groupName, fieldName);\n  }\n\n  function isPending(fieldName?: F): boolean {\n    return fieldName\n      ? greaterThan(summary.tests[fieldName]?.pendingCount, 0)\n      : greaterThan(summary.pendingCount, 0);\n  }\n}\n\nexport interface SuiteSelectors<F extends TFieldName, G extends TGroupName> {\n  getWarning(): SummaryFailure<F, G> | undefined;\n  getWarning(fieldName: F): string | undefined;\n  getWarning(fieldName?: F): SummaryFailure<F, G> | string | undefined;\n  getError(): SummaryFailure<F, G> | undefined;\n  getError(fieldName: F): string | undefined;\n  getError(fieldName?: F): SummaryFailure<F, G> | string | undefined;\n  getMessage(fieldName: F): string | undefined;\n  getErrors(): FailureMessages;\n  getErrors(fieldName: F): string[];\n  getErrors(fieldName?: F): string[] | FailureMessages;\n  getWarnings(): FailureMessages;\n  getWarnings(fieldName: F): string[];\n  getWarnings(fieldName?: F): string[] | FailureMessages;\n  getErrorsByGroup(groupName: G): FailureMessages;\n  getErrorsByGroup(groupName: G, fieldName: F): string[];\n  getErrorsByGroup(groupName: G, fieldName?: F): string[] | FailureMessages;\n  getWarningsByGroup(groupName: G): FailureMessages;\n  getWarningsByGroup(groupName: G, fieldName: F): string[];\n  getWarningsByGroup(groupName: G, fieldName?: F): string[] | FailureMessages;\n  hasErrors(fieldName?: F): boolean;\n  hasWarnings(fieldName?: F): boolean;\n  hasErrorsByGroup(groupName: G, fieldName?: F): boolean;\n  hasWarningsByGroup(groupName: G, fieldName?: F): boolean;\n  isTested(fieldName: F): boolean;\n  isPending(fieldName?: F): boolean;\n  isValid(fieldName?: F): boolean;\n  isValidByGroup(groupName: G, fieldName?: F): boolean;\n}\n\n// Gathers all failures of a given severity\n// With a fieldName, it will only gather failures for that field\nfunction getFailures<F extends TFieldName, G extends TGroupName>(\n  summary: SuiteSummary<F, G>,\n  severityKey: Severity,\n): FailureMessages;\nfunction getFailures<F extends TFieldName, G extends TGroupName>(\n  summary: SuiteSummary<F, G>,\n  severityKey: Severity,\n  fieldName?: TFieldName,\n): string[];\nfunction getFailures<F extends TFieldName, G extends TGroupName>(\n  summary: SuiteSummary<F, G>,\n  severityKey: Severity,\n  fieldName?: TFieldName,\n): GetFailuresResponse {\n  return gatherFailures(summary.tests, severityKey, fieldName);\n}\n\n// Gathers all failures of a given severity within a group\n// With a fieldName, it will only gather failures for that field\nfunction getFailuresByGroup(\n  summary: SuiteSummary<TFieldName, TGroupName>,\n  severityKey: Severity,\n  groupName: TGroupName,\n  fieldName?: TFieldName,\n): GetFailuresResponse {\n  return gatherFailures(summary.groups[groupName], severityKey, fieldName);\n}\n// Checks if a field is valid within a container object - can be within a group or top level\nfunction isFieldValid(\n  testContainer: TestsContainer<TFieldName, TGroupName>,\n  fieldName: TFieldName,\n): boolean {\n  return !!testContainer[fieldName]?.valid;\n}\n\n// Checks if a there are any failures of a given severity within a group\n// If a fieldName is provided, it will only check for failures within that field\nfunction hasFailuresByGroup(\n  summary: SuiteSummary<TFieldName, TGroupName>,\n  severityCount: SeverityCount,\n  groupName: TGroupName,\n  fieldName?: TFieldName,\n): boolean {\n  const group = summary.groups[groupName];\n\n  if (!group) {\n    return false;\n  }\n\n  if (fieldName) {\n    return isPositive(group[fieldName]?.[severityCount]);\n  }\n\n  for (const field in group) {\n    if (isPositive(group[field]?.[severityCount])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Checks if there are any failures of a given severity\n// If a fieldName is provided, it will only check for failures within that field\nfunction hasFailures(\n  summary: SuiteSummary<TFieldName, TGroupName>,\n  countKey: SeverityCount,\n  fieldName?: TFieldName,\n): boolean {\n  const failureCount = fieldName\n    ? summary.tests[fieldName]?.[countKey]\n    : summary[countKey] || 0;\n\n  return isPositive(failureCount);\n}\n\nfunction getFailure<F extends TFieldName, G extends TGroupName>(\n  severity: Severity,\n  summary: SuiteSummary<F, G>,\n): Maybe<SummaryFailure<F, G>>;\nfunction getFailure<F extends TFieldName, G extends TGroupName>(\n  severity: Severity,\n  summary: SuiteSummary<F, G>,\n  fieldName: F,\n): Maybe<string>;\nfunction getFailure<F extends TFieldName, G extends TGroupName>(\n  severity: Severity,\n  summary: SuiteSummary<F, G>,\n  fieldName?: F,\n): Maybe<SummaryFailure<F, G> | string> {\n  const summaryKey = summary[severity];\n\n  if (!fieldName) {\n    return summaryKey[0];\n  }\n\n  return summaryKey.find(\n    (summaryFailure: SummaryFailure<TFieldName, TGroupName>) =>\n      matchingFieldName(summaryFailure, fieldName),\n  )?.message;\n}\n","import { TIsolateTest } from 'IsolateTest';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { WithFieldName } from 'TestTypes';\nimport { VestTest } from 'VestTest';\n\nexport class SummaryFailure<F extends TFieldName, G extends TGroupName>\n  implements WithFieldName<F>\n{\n  constructor(\n    public fieldName: F,\n    public message: string | undefined,\n    public groupName: G | undefined,\n  ) {}\n\n  static fromTestObject<F extends TFieldName, G extends TGroupName>(\n    testObject: TIsolateTest<F, G>,\n  ) {\n    const { fieldName, message, groupName } = VestTest.getData(testObject);\n\n    return new SummaryFailure(fieldName, message, groupName);\n  }\n}\n","import { Nullable } from 'vest-utils';\nimport { Walker, VestRuntime, TIsolate } from 'vestjs-runtime';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { VestTest } from 'VestTest';\nimport matchingFieldName from 'matchingFieldName';\n\ntype MaybeRoot = Nullable<TIsolate>;\n\nexport class TestWalker {\n  static defaultRoot = VestRuntime.useAvailableRoot;\n\n  static hasNoTests(root: MaybeRoot = TestWalker.defaultRoot()): boolean {\n    if (!root) return true;\n    return !Walker.has(root, VestTest.is);\n  }\n\n  static someTests(\n    predicate: (test: TIsolateTest) => boolean,\n    root: MaybeRoot = TestWalker.defaultRoot(),\n  ): boolean {\n    if (!root) return false;\n    return Walker.some(\n      root,\n      isolate => {\n        VestTest.isX(isolate);\n\n        return predicate(isolate);\n      },\n      VestTest.is,\n    );\n  }\n\n  static everyTest(\n    predicate: (test: TIsolateTest) => boolean,\n    root: MaybeRoot = TestWalker.defaultRoot(),\n  ): boolean {\n    if (!root) return false;\n    return Walker.every(\n      root,\n      isolate => {\n        VestTest.isX(isolate);\n\n        return predicate(isolate);\n      },\n      VestTest.is,\n    );\n  }\n\n  static walkTests<F extends TFieldName, G extends TGroupName>(\n    callback: (test: TIsolateTest<F, G>, breakout: () => void) => void,\n    root: MaybeRoot = TestWalker.defaultRoot(),\n  ): void {\n    if (!root) return;\n    Walker.walk(\n      root,\n      (isolate, breakout) => {\n        callback(VestTest.cast<F, G>(isolate), breakout);\n      },\n      VestTest.is,\n    );\n  }\n\n  static reduceTests<T, I extends TIsolateTest = TIsolateTest>(\n    callback: (acc: T, test: I, breakout: () => void) => T,\n    initialValue: T,\n    root: MaybeRoot = TestWalker.defaultRoot(),\n  ): T {\n    if (!root) return initialValue;\n    return Walker.reduce(\n      root,\n      (acc, isolate, breakout) => {\n        return callback(acc, VestTest.cast(isolate) as I, breakout);\n      },\n      initialValue,\n      VestTest.is,\n    );\n  }\n\n  static pluckTests(\n    predicate: (test: TIsolateTest) => boolean,\n    root: MaybeRoot = TestWalker.defaultRoot(),\n  ): void {\n    if (!root) return;\n    Walker.pluck(\n      root,\n      isolate => {\n        VestTest.isX(isolate);\n\n        return predicate(isolate);\n      },\n      VestTest.is,\n    );\n  }\n\n  static resetField(fieldName: TFieldName): void {\n    TestWalker.walkTests(testObject => {\n      if (matchingFieldName(VestTest.getData(testObject), fieldName)) {\n        VestTest.reset(testObject);\n      }\n    }, TestWalker.defaultRoot());\n  }\n\n  static removeTestByFieldName(\n    fieldName: TFieldName,\n    root: MaybeRoot = TestWalker.defaultRoot(),\n  ): void {\n    TestWalker.pluckTests(testObject => {\n      return matchingFieldName(VestTest.getData(testObject), fieldName);\n    }, root);\n  }\n}\n","import { Predicate, Predicates, isEmpty, isNullish } from 'vest-utils';\nimport { TIsolate, VestRuntime, Walker } from 'vestjs-runtime';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { PreAggCache, usePreAggCache } from 'Runtime';\nimport { TFieldName } from 'SuiteResultTypes';\nimport { VestIsolate } from 'VestIsolate';\nimport { VestTest } from 'VestTest';\nimport { matchesOrHasNoFieldName } from 'matchingFieldName';\n\nexport class SuiteWalker {\n  static defaultRoot = VestRuntime.useAvailableRoot;\n\n  static useHasPending(predicate?: Predicate): boolean {\n    const root = SuiteWalker.defaultRoot();\n\n    if (!root) {\n      return false;\n    }\n\n    const allPending = SuiteWalker.usePreAggs().pending;\n\n    if (isEmpty(allPending)) {\n      return false;\n    }\n\n    return allPending.some(Predicates.all(predicate ?? true));\n  }\n\n  static usePreAggs() {\n    return usePreAggCache(buildPreAggCache);\n  }\n\n  // Checks whether there are pending isolates in the tree.\n  // If a fieldname is provided, will only check tests with a matching fieldname.\n  static useHasRemainingWithTestNameMatching(fieldName?: TFieldName): boolean {\n    return SuiteWalker.useHasPending(\n      Predicates.any(\n        isNullish(fieldName),\n        Predicates.all(VestTest.is, (testObject: TIsolateTest) => {\n          return matchesOrHasNoFieldName(\n            VestTest.getData(testObject),\n            fieldName,\n          );\n        }),\n      ),\n    );\n  }\n}\n\nfunction buildPreAggCache(): PreAggCache {\n  const root = SuiteWalker.defaultRoot();\n\n  const base: PreAggCache = {\n    pending: [],\n    failures: {\n      errors: {},\n      warnings: {},\n    },\n  };\n\n  if (!root) {\n    return base;\n  }\n\n  return Walker.reduce(\n    root,\n    // eslint-disable-next-line complexity, max-statements\n    (agg, isolate: TIsolate) => {\n      if (VestIsolate.isPending(isolate)) {\n        agg.pending.push(isolate);\n      }\n\n      if (VestTest.is(isolate)) {\n        const fieldName = VestTest.getData(isolate).fieldName;\n\n        if (VestTest.isWarning(isolate)) {\n          agg.failures.warnings[fieldName] =\n            agg.failures.warnings[fieldName] ?? [];\n          agg.failures.warnings[fieldName].push(isolate);\n        }\n\n        if (VestTest.isFailing(isolate)) {\n          agg.failures.errors[fieldName] = agg.failures.errors[fieldName] ?? [];\n          agg.failures.errors[fieldName].push(isolate);\n        }\n      }\n\n      return agg;\n    },\n    base,\n  );\n}\n","import { Maybe, bindNot } from 'vest-utils';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { TGroupName } from 'SuiteResultTypes';\nimport { VestTest } from 'VestTest';\n\nexport const nonMatchingGroupName = bindNot(matchingGroupName);\n\nexport function matchingGroupName(\n  testObject: TIsolateTest,\n  groupName: Maybe<TGroupName>,\n): boolean {\n  return VestTest.getData(testObject).groupName === groupName;\n}\n","import { isEmpty } from 'vest-utils';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { Severity } from 'Severity';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { SuiteWalker } from 'SuiteWalker';\nimport { TestWalker } from 'TestWalker';\nimport { VestTest } from 'VestTest';\nimport { nonMatchingFieldName } from 'matchingFieldName';\nimport { nonMatchingGroupName } from 'matchingGroupName';\nimport { nonMatchingSeverityProfile } from 'nonMatchingSeverityProfile';\n\n/**\n * The difference between this file and hasFailures is that hasFailures uses the static\n * summary object, while this one uses the actual validation state\n */\n\nexport function hasErrorsByTestObjects(fieldName?: TFieldName): boolean {\n  return hasFailuresByTestObjects(Severity.ERRORS, fieldName);\n}\n\nfunction hasFailuresByTestObjects(\n  severityKey: Severity,\n  fieldName?: TFieldName,\n): boolean {\n  const allFailures = SuiteWalker.usePreAggs().failures;\n\n  if (isEmpty(allFailures[severityKey])) {\n    return false;\n  }\n\n  if (fieldName) {\n    return !isEmpty(allFailures[severityKey][fieldName]);\n  }\n\n  return true;\n}\n\nexport function hasGroupFailuresByTestObjects(\n  severityKey: Severity,\n  groupName: TGroupName,\n  fieldName?: TFieldName,\n): boolean {\n  return TestWalker.someTests(testObject => {\n    if (nonMatchingGroupName(testObject, groupName)) {\n      return false;\n    }\n\n    return hasFailuresByTestObject(testObject, severityKey, fieldName);\n  });\n}\n\n/**\n * Determines whether a certain test profile has failures.\n */\nexport function hasFailuresByTestObject(\n  testObject: TIsolateTest,\n  severityKey: Severity,\n  fieldName?: TFieldName,\n): boolean {\n  if (!VestTest.hasFailures(testObject)) {\n    return false;\n  }\n\n  if (nonMatchingFieldName(VestTest.getData(testObject), fieldName)) {\n    return false;\n  }\n\n  if (nonMatchingSeverityProfile(severityKey, testObject)) {\n    return false;\n  }\n\n  return true;\n}\n","import { either } from 'vest-utils';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { Severity } from 'Severity';\nimport { VestTest } from 'VestTest';\n\n/**\n * Checks that a given test object matches the currently specified severity level\n */\nexport function nonMatchingSeverityProfile(\n  severity: Severity,\n  testObject: TIsolateTest,\n): boolean {\n  return either(severity === Severity.WARNINGS, VestTest.warns(testObject));\n}\n","import { useIsOptionalFieldApplied } from 'optional';\nimport { Predicates } from 'vest-utils';\nimport { VestRuntime } from 'vestjs-runtime';\n\nimport { SuiteOptionalFields, TIsolateSuite } from 'IsolateSuite';\nimport { TIsolateTest } from 'IsolateTest';\nimport { OptionalFieldTypes } from 'OptionalTypes';\nimport { Severity } from 'Severity';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { SuiteWalker } from 'SuiteWalker';\nimport { TestWalker } from 'TestWalker';\nimport { VestTest } from 'VestTest';\nimport {\n  hasErrorsByTestObjects,\n  hasGroupFailuresByTestObjects,\n} from 'hasFailuresByTestObjects';\nimport { nonMatchingFieldName } from 'matchingFieldName';\nimport { nonMatchingGroupName } from 'matchingGroupName';\n\nexport function useShouldAddValidProperty(fieldName?: TFieldName): boolean {\n  // Is the field optional, and the optional condition is applied\n  if (useIsOptionalFieldApplied(fieldName)) {\n    return true;\n  }\n\n  // Are there no tests?\n  if (TestWalker.hasNoTests()) {\n    return false;\n  }\n\n  // // Does the field have any tests with errors?\n  if (hasErrorsByTestObjects(fieldName)) {\n    return false;\n  }\n\n  // Does the given field have any pending tests that are not optional?\n  if (useHasNonOptionalIncomplete(fieldName)) {\n    return false;\n  }\n\n  // Does the field have no missing tests?\n  return useNoMissingTests(fieldName);\n}\n\nexport function useShouldAddValidPropertyInGroup(\n  groupName: TGroupName,\n  fieldName: TFieldName,\n): boolean {\n  if (useIsOptionalFieldApplied(fieldName)) {\n    return true;\n  }\n\n  if (hasGroupFailuresByTestObjects(Severity.ERRORS, groupName, fieldName)) {\n    return false;\n  }\n\n  // Do the given group/field have any pending tests that are not optional?\n  if (useHasNonOptionalIncompleteByGroup(groupName, fieldName)) {\n    return false;\n  }\n\n  return useNoMissingTestsByGroup(groupName, fieldName);\n}\n\n// Does the given field have any pending tests that are not optional?\nfunction useHasNonOptionalIncomplete(fieldName?: TFieldName) {\n  return SuiteWalker.useHasPending(\n    Predicates.all(\n      VestTest.is,\n      (testObject: TIsolateTest) =>\n        !nonMatchingFieldName(VestTest.getData(testObject), fieldName),\n      () => !useIsOptionalFieldApplied(fieldName),\n    ),\n  );\n}\n\n// Do the given group/field have any pending tests that are not optional?\nfunction useHasNonOptionalIncompleteByGroup(\n  groupName: TGroupName,\n  fieldName: TFieldName,\n): boolean {\n  return SuiteWalker.useHasPending(\n    Predicates.all(\n      VestTest.is,\n      (testObject: TIsolateTest) =>\n        !nonMatchingGroupName(testObject, groupName),\n      (testObject: TIsolateTest) =>\n        !nonMatchingFieldName(VestTest.getData(testObject), fieldName),\n      () => !useIsOptionalFieldApplied(fieldName),\n    ),\n  );\n}\n\n// Did all of the tests for the provided field run/omit?\n// This makes sure that the fields are not skipped or pending.\nfunction useNoMissingTests(fieldName?: string): boolean {\n  return TestWalker.everyTest(testObject => {\n    return useNoMissingTestsLogic(testObject, fieldName);\n  });\n}\n\n// Does the group have no missing tests?\nfunction useNoMissingTestsByGroup(\n  groupName: TGroupName,\n  fieldName?: TFieldName,\n): boolean {\n  return TestWalker.everyTest(testObject => {\n    if (nonMatchingGroupName(testObject, groupName)) {\n      return true;\n    }\n\n    return useNoMissingTestsLogic(testObject, fieldName);\n  });\n}\n\nfunction useNoMissingTestsLogic(\n  testObject: TIsolateTest,\n  fieldName?: TFieldName,\n): boolean {\n  if (nonMatchingFieldName(VestTest.getData(testObject), fieldName)) {\n    return true;\n  }\n\n  /**\n   * The reason we're checking for the optional field here and not in \"omitOptionalFields\"\n   * is because that unlike the bool/function check we do there, here it only depends on\n   * whether the field was tested already or not.\n   *\n   * We qualify the test as not missing only if it was already run, if it is omitted,\n   * or if it is marked as optional, even if the optional check did not apply yet -\n   * but the test did not reach its final state.\n   */\n\n  return (\n    VestTest.isOmitted(testObject) ||\n    VestTest.isTested(testObject) ||\n    useOptionalTestAwaitsResolution(testObject)\n  );\n}\n\nfunction useOptionalTestAwaitsResolution(testObject: TIsolateTest): boolean {\n  // Does the test belong to an optional field,\n  // and the test itself is still in an indeterminate state?\n\n  const root = VestRuntime.useAvailableRoot<TIsolateSuite>();\n\n  const { fieldName } = VestTest.getData(testObject);\n\n  return (\n    SuiteOptionalFields.getOptionalField(root, fieldName).type ===\n      OptionalFieldTypes.AUTO && VestTest.awaitsResolution(testObject)\n  );\n}\n","import { Maybe, assign, defaultTo } from 'vest-utils';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { countKeyBySeverity, Severity } from 'Severity';\nimport {\n  Groups,\n  SingleTestSummary,\n  SuiteSummary,\n  SummaryBase,\n  TFieldName,\n  TGroupName,\n  Tests,\n} from 'SuiteResultTypes';\nimport { SummaryFailure } from 'SummaryFailure';\nimport { TestWalker } from 'TestWalker';\nimport { VestTest } from 'VestTest';\nimport {\n  useShouldAddValidProperty,\n  useShouldAddValidPropertyInGroup,\n} from 'shouldAddValidProperty';\n\nexport function useProduceSuiteSummary<\n  F extends TFieldName,\n  G extends TGroupName,\n>(): SuiteSummary<F, G> {\n  // @vx-allow use-use (TODO: fix this. the error is in the lint rule)\n  const summary = TestWalker.reduceTests<\n    SuiteSummary<F, G>,\n    TIsolateTest<F, G>\n  >((summary, testObject) => {\n    const fieldName = VestTest.getData<F>(testObject).fieldName;\n    summary.tests[fieldName] = useAppendToTest(summary.tests, testObject);\n    summary.groups = useAppendToGroup(summary.groups, testObject);\n\n    if (VestTest.isOmitted(testObject)) {\n      return summary;\n    }\n    if (summary.tests[fieldName].valid === false) {\n      summary.valid = false;\n    }\n    return addSummaryStats(testObject, summary);\n  }, new SuiteSummary());\n\n  summary.valid = summary.valid === false ? false : useShouldAddValidProperty();\n\n  return summary;\n}\n\nfunction addSummaryStats<F extends TFieldName, G extends TGroupName>(\n  testObject: TIsolateTest<F, G>,\n  summary: SuiteSummary<F, G>,\n): SuiteSummary<F, G> {\n  if (VestTest.isWarning(testObject)) {\n    summary.warnCount++;\n    summary.warnings.push(SummaryFailure.fromTestObject(testObject));\n  } else if (VestTest.isFailing(testObject)) {\n    summary.errorCount++;\n    summary.errors.push(SummaryFailure.fromTestObject(testObject));\n  }\n\n  if (VestTest.isPending(testObject)) {\n    summary.pendingCount++;\n  }\n\n  if (shouldCountTestRun(testObject)) {\n    summary.testCount++;\n  }\n\n  return summary;\n}\n\nfunction useAppendToTest<F extends TFieldName>(\n  tests: Tests<F>,\n  testObject: TIsolateTest<F>,\n): SingleTestSummary {\n  const fieldName = VestTest.getData<F>(testObject).fieldName;\n\n  const test = appendTestObject(tests[fieldName], testObject);\n  // If `valid` is false to begin with, keep it that way. Otherwise, assess.\n  test.valid =\n    test.valid === false ? false : useShouldAddValidProperty(fieldName);\n\n  return test;\n}\n\n/**\n * Appends to a group object if within a group\n */\nfunction useAppendToGroup(\n  groups: Groups<TGroupName, TFieldName>,\n  testObject: TIsolateTest,\n): Groups<TGroupName, TFieldName> {\n  const { groupName, fieldName } = VestTest.getData(testObject);\n\n  if (!groupName) {\n    return groups;\n  }\n\n  groups[groupName] = groups[groupName] || {};\n  const group = groups[groupName];\n  group[fieldName] = appendTestObject(group[fieldName], testObject);\n\n  group[fieldName].valid =\n    group[fieldName].valid === false\n      ? false\n      : useShouldAddValidPropertyInGroup(groupName, fieldName);\n\n  return groups;\n}\n\n/**\n * Appends the test to a results object.\n */\n// eslint-disable-next-line max-statements, complexity\nfunction appendTestObject(\n  summaryKey: Maybe<SingleTestSummary>,\n  testObject: TIsolateTest,\n): SingleTestSummary {\n  const { message } = VestTest.getData(testObject);\n\n  // Let's first create a new object, so we don't mutate the original.\n  const nextSummaryKey = defaultTo<SingleTestSummary>(\n    summaryKey ? { ...summaryKey } : null,\n    baseTestStats,\n  );\n\n  // If the test is not actionable, we don't need to append it to the summary.\n  if (VestTest.isNonActionable(testObject)) return nextSummaryKey;\n\n  // Increment the pending count if the test is pending.\n  if (VestTest.isPending(testObject)) {\n    nextSummaryKey.pendingCount++;\n  }\n\n  // Increment the error count if the test is failing.\n  if (VestTest.isFailing(testObject)) {\n    incrementFailures(Severity.ERRORS);\n  } else if (VestTest.isWarning(testObject)) {\n    // Increment the warning count if the test is warning.\n    incrementFailures(Severity.WARNINGS);\n  }\n\n  // Increment the test count.\n  if (shouldCountTestRun(testObject)) {\n    nextSummaryKey.testCount++;\n  }\n\n  return nextSummaryKey;\n\n  // Helper function to increment the failure count.\n  function incrementFailures(severity: Severity) {\n    const countKey = countKeyBySeverity(severity);\n    nextSummaryKey[countKey]++;\n    if (message) {\n      nextSummaryKey[severity] = (nextSummaryKey[severity] || []).concat(\n        message,\n      );\n    }\n  }\n}\n\nfunction baseTestStats() {\n  return assign(new SummaryBase(), {\n    errors: [],\n    valid: true,\n    warnings: [],\n  });\n}\n\nfunction shouldCountTestRun<F extends TFieldName, G extends TGroupName>(\n  testObject: TIsolateTest<F, G>,\n): boolean {\n  return VestTest.isTested(testObject) || VestTest.isPending(testObject);\n}\n","import { assign, Maybe } from 'vest-utils';\n\nimport { useSuiteName, useSuiteResultCache } from 'Runtime';\nimport {\n  SuiteResult,\n  SuiteSummary,\n  TFieldName,\n  TGroupName,\n} from 'SuiteResultTypes';\nimport { suiteSelectors } from 'suiteSelectors';\nimport { useProduceSuiteSummary } from 'useProduceSuiteSummary';\n\nexport function useCreateSuiteResult<\n  F extends TFieldName,\n  G extends TGroupName,\n>(): SuiteResult<F, G> {\n  return useSuiteResultCache<F, G>(() => {\n    // @vx-allow use-use\n    const summary = useProduceSuiteSummary<F, G>();\n\n    // @vx-allow use-use\n    const suiteName = useSuiteName();\n\n    return Object.freeze(constructSuiteResultObject<F, G>(summary, suiteName));\n  });\n}\n\nexport function constructSuiteResultObject<\n  F extends TFieldName,\n  G extends TGroupName,\n>(summary: SuiteSummary<F, G>, suiteName?: Maybe<string>): SuiteResult<F, G> {\n  return assign(summary, suiteSelectors<F, G>(summary), {\n    suiteName,\n  }) as SuiteResult<F, G>;\n}\n","import {\n  SuiteResult,\n  SuiteSummary,\n  TFieldName,\n  TGroupName,\n} from 'SuiteResultTypes';\nimport { constructSuiteResultObject, useCreateSuiteResult } from 'suiteResult';\n\n// @vx-allow use-use\nexport function LazyDraft<\n  F extends TFieldName,\n  G extends TGroupName,\n>(): SuiteResult<F, G> {\n  const emptySummary = constructSuiteResultObject(new SuiteSummary<F, G>());\n\n  return new Proxy(emptySummary, {\n    get: (_, prop) => {\n      // @vx-allow use-use\n      const result = useCreateSuiteResult<F, G>();\n\n      return result[prop as keyof SuiteResult<F, G>];\n    },\n  }) as SuiteResult<F, G>;\n}\n","import { CB, optionalFunctionValue } from 'vest-utils';\nimport { Isolate } from 'vestjs-runtime';\n\nimport { LazyDraft } from 'LazyDraft';\nimport { SuiteContext, useSkipped } from 'SuiteContext';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { VestIsolateType } from 'VestIsolateType';\nimport { TDraftCondition } from 'getTypedMethods';\n\n/**\n * Conditionally skips running tests within the callback.\n *\n * @example\n *\n * skipWhen(res => res.hasErrors('username'), () => {\n *  test('username', 'User already taken', async () => await doesUserExist(username)\n * });\n */\n// @vx-allow use-use\nexport function skipWhen<F extends TFieldName, G extends TGroupName>(\n  condition: TDraftCondition<F, G>,\n  callback: CB,\n): void {\n  Isolate.create(VestIsolateType.SkipWhen, () => {\n    SuiteContext.run(\n      {\n        skipped:\n          // Checking for nested conditional. If we're in a nested skipWhen,\n          // we should skip the test if the parent conditional is true.\n          useIsExcludedIndividually() ||\n          // Otherwise, we should skip the test if the conditional is true.\n          optionalFunctionValue(condition, LazyDraft<F, G>()),\n      },\n      callback,\n    );\n  });\n}\n\nexport function useIsExcludedIndividually(): boolean {\n  return useSkipped();\n}\n","import { isNotNullish } from 'vest-utils';\nimport { TIsolate, Walker } from 'vestjs-runtime';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { TFieldName } from 'SuiteResultTypes';\nimport { FocusSelectors } from 'focused';\n\n/**\n * Checks if context has included tests\n */\nexport function useHasOnliedTests(\n  testObject: TIsolateTest,\n  fieldName?: TFieldName,\n): boolean {\n  return isNotNullish(\n    Walker.findClosest(testObject, (child: TIsolate) => {\n      if (!FocusSelectors.isIsolateFocused(child)) return false;\n\n      return FocusSelectors.isOnlyFocused(child, fieldName);\n    }),\n  );\n}\n","import { Nullable, optionalFunctionValue } from 'vest-utils';\nimport { TIsolate, Walker } from 'vestjs-runtime';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { useInclusion } from 'SuiteContext';\nimport { VestTest } from 'VestTest';\nimport { FocusSelectors, TIsolateFocused } from 'focused';\nimport { useIsExcludedIndividually } from 'skipWhen';\nimport { useHasOnliedTests } from 'useHasOnliedTests';\n//Checks whether a certain test profile excluded by any of the exclusion groups.\n\nfunction useClosestMatchingFocus(\n  testObject: TIsolateTest,\n): Nullable<TIsolateFocused> {\n  return Walker.findClosest(testObject, (child: TIsolate) => {\n    if (!FocusSelectors.isIsolateFocused(child)) return false;\n\n    const { fieldName } = VestTest.getData(testObject);\n\n    return child.data.match?.includes(fieldName) || child.data.matchAll;\n  });\n}\n\nexport function useIsExcluded(testObject: TIsolateTest): boolean {\n  const { fieldName } = VestTest.getData(testObject);\n\n  if (useIsExcludedIndividually()) return true;\n  const inclusion = useInclusion();\n  const focusMatch = useClosestMatchingFocus(testObject);\n  // if test is skipped\n  // no need to proceed\n  if (FocusSelectors.isSkipFocused(focusMatch)) return true;\n  const isTestIncluded = FocusSelectors.isOnlyFocused(focusMatch);\n  // if field is only'ed\n  if (isTestIncluded) return false;\n\n  // If there is _ANY_ `only`ed test (and we already know this one isn't) return true\n  if (useHasOnliedTests(testObject)) {\n    // Check if inclusion rules for this field (`include` hook)\n    return !optionalFunctionValue(inclusion[fieldName], testObject);\n  }\n\n  // We're done here. This field is not excluded\n  return false;\n}\n","import { Modes } from 'Modes';\nimport { useMode } from 'SuiteContext';\nimport { WithFieldName } from 'TestTypes';\nimport { hasErrorsByTestObjects } from 'hasFailuresByTestObjects';\n\n/**\n * Sets the current execution mode for the current suite.\n *\n * Supported modes:\n * - `EAGER` - (default) Runs all tests, but stops on first failure for each given field.\n * - `ALL` - Runs all tests, regardless of failures.\n * - `ONE` - Stops suite execution on first failure of any field.\n *\n * @example\n * ```js\n * import {Modes, create} from 'vest';\n *\n * const suite = create('suite_name', () => {\n *  vest.mode(Modes.ALL);\n *\n *  // ...\n * });\n * ```\n * @param 'ALL' | 'EAGER' | 'ONE' mode - The mode to set.\n */\n\n// @vx-allow use-use\nexport function mode(mode: Modes): void {\n  const [, setMode] = useMode();\n\n  setMode(mode);\n}\n\nfunction useIsMode(mode: Modes): boolean {\n  const [currentMode] = useMode();\n\n  return currentMode === mode;\n}\n\nfunction useIsEager(): boolean {\n  return useIsMode(Modes.EAGER);\n}\n\nfunction useIsOne(): boolean {\n  return useIsMode(Modes.ONE);\n}\n\nexport function useShouldSkipBasedOnMode(testData: WithFieldName): boolean {\n  if (useIsOne()) {\n    return hasErrorsByTestObjects();\n  }\n\n  if (useIsEager()) {\n    return hasErrorsByTestObjects(testData.fieldName);\n  }\n\n  return false;\n}\n","import type { CB } from 'vest-utils';\nimport { optionalFunctionValue } from 'vest-utils';\nimport { Isolate } from 'vestjs-runtime';\n\nimport { LazyDraft } from 'LazyDraft';\nimport { SuiteContext, useOmitted } from 'SuiteContext';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { VestIsolateType } from 'VestIsolateType';\nimport { TDraftCondition } from 'getTypedMethods';\n\n/**\n * Conditionally omits tests from the suite.\n *\n * @example\n *\n * omitWhen(res => res.hasErrors('username'), () => {\n *  test('username', 'User already taken', async () => await doesUserExist(username)\n * });\n */\n// @vx-allow use-use\nexport function omitWhen<F extends TFieldName, G extends TGroupName>(\n  conditional: TDraftCondition<F, G>,\n  callback: CB,\n): void {\n  Isolate.create(VestIsolateType.OmitWhen, () => {\n    SuiteContext.run(\n      {\n        omitted:\n          useWithinActiveOmitWhen() ||\n          optionalFunctionValue(conditional, LazyDraft<F, G>()),\n      },\n      callback,\n    );\n  });\n}\n\n// Checks that we're currently in an active omitWhen block\nexport function useWithinActiveOmitWhen(): boolean {\n  return useOmitted();\n}\n","import { useIsOptionalFieldApplied } from 'optional';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { TFieldName } from 'SuiteResultTypes';\nimport { VestTest } from 'VestTest';\nimport { useShouldSkipBasedOnMode } from 'mode';\nimport { useWithinActiveOmitWhen } from 'omitWhen';\nimport { useIsExcludedIndividually } from 'skipWhen';\nimport { useIsExcluded } from 'useIsExcluded';\n\n// eslint-disable-next-line complexity\nexport function useVerifyTestRun(\n  testObject: TIsolateTest,\n  collisionResult: TIsolateTest = testObject,\n): TIsolateTest {\n  const testData = VestTest.getData(testObject);\n\n  if (useShouldSkipBasedOnMode(testData)) {\n    return skipTestAndReturn(testObject);\n  }\n\n  if (useShouldOmit(testData.fieldName)) {\n    return omitTestAndReturn(testObject);\n  }\n\n  if (useIsExcluded(testObject)) {\n    return useForceSkipIfInSkipWhen(collisionResult);\n  }\n\n  return testObject;\n}\n\nfunction useShouldOmit(fieldName: TFieldName): boolean {\n  return useWithinActiveOmitWhen() || useIsOptionalFieldApplied(fieldName);\n}\n\nfunction skipTestAndReturn(testNode: TIsolateTest): TIsolateTest {\n  VestTest.skip(testNode);\n  return testNode;\n}\n\nfunction omitTestAndReturn(testNode: TIsolateTest): TIsolateTest {\n  VestTest.omit(testNode);\n  return testNode;\n}\n\nfunction useForceSkipIfInSkipWhen(testNode: TIsolateTest): TIsolateTest {\n  // We're forcing skipping the pending test\n  // if we're directly within a skipWhen block\n  // This mostly means that we're probably giving\n  // up on this async test intentionally.\n  VestTest.skip(testNode, useIsExcludedIndividually());\n  return testNode;\n}\n","import { Maybe, deferThrow, text } from 'vest-utils';\nimport { IsolateInspector, Reconciler } from 'vestjs-runtime';\nimport type { TIsolate } from 'vestjs-runtime';\n\nimport { ErrorStrings } from 'ErrorStrings';\nimport type { TIsolateTest } from 'IsolateTest';\nimport { VestTest } from 'VestTest';\nimport cancelOverriddenPendingTest from 'cancelOverriddenPendingTest';\nimport { isSameProfileTest } from 'isSameProfileTest';\nimport { useIsExcluded } from 'useIsExcluded';\nimport { useVerifyTestRun } from 'verifyTestRun';\n\nexport class IsolateTestReconciler {\n  static match(currentNode: TIsolate, historyNode: TIsolate): boolean {\n    return VestTest.is(currentNode) && VestTest.is(historyNode);\n  }\n\n  static reconcile(\n    currentNode: TIsolateTest,\n    historyNode: TIsolateTest,\n  ): TIsolateTest {\n    const reconcilerOutput = usePickNode(currentNode, historyNode);\n\n    const nextNode = useVerifyTestRun(currentNode, reconcilerOutput);\n\n    cancelOverriddenPendingTestOnTestReRun(nextNode, currentNode, historyNode);\n\n    return nextNode;\n  }\n}\n\nfunction usePickNode(\n  newNode: TIsolateTest,\n  prevNode: TIsolateTest,\n): TIsolateTest {\n  if (IsolateInspector.usesKey(newNode)) {\n    return useHandleTestWithKey(newNode);\n  }\n\n  if (\n    Reconciler.dropNextNodesOnReorder(nodeReorderDetected, newNode, prevNode)\n  ) {\n    throwTestOrderError(newNode, prevNode);\n    return newNode;\n  }\n\n  if (!VestTest.is(prevNode)) {\n    // I believe we cannot actually reach this point.\n    // Because it should already be handled by nodeReorderDetected.\n    /* istanbul ignore next */\n    return newNode;\n  }\n\n  // FIXME: May-13-2023\n  // This may not be the most ideal solution.\n  // In short: if the node was omitted in the previous run,\n  // we want to re-evaluate it. The reason is that we may incorrectly\n  // identify it is \"optional\" because it was omitted in the previous run.\n  // There may be a better way to handle this. Need to revisit this.\n  if (VestTest.isOmitted(prevNode)) {\n    return newNode;\n  }\n\n  return prevNode;\n}\n\nfunction useHandleTestWithKey(newNode: TIsolateTest): TIsolateTest {\n  return VestTest.cast(\n    Reconciler.handleIsolateNodeWithKey(newNode, (prevNode: TIsolateTest) => {\n      // This is the revoke callback. it determines whether we should revoke the previous node and use the new one.\n      if (VestTest.isNonActionable(prevNode)) {\n        return true;\n      }\n\n      if (useIsExcluded(newNode)) {\n        return false;\n      }\n\n      return true;\n    }),\n  );\n}\n\nfunction cancelOverriddenPendingTestOnTestReRun(\n  nextNode: TIsolate,\n  currentNode: TIsolate,\n  prevTestObject: TIsolateTest,\n) {\n  if (nextNode === currentNode && VestTest.is(currentNode)) {\n    cancelOverriddenPendingTest(prevTestObject, currentNode);\n  }\n}\n\nfunction nodeReorderDetected(\n  newNode: TIsolateTest,\n  prevNode: Maybe<TIsolate>,\n): boolean {\n  return VestTest.is(prevNode) && !isSameProfileTest(prevNode, newNode);\n}\n\nfunction throwTestOrderError(\n  newNode: TIsolateTest,\n  prevNode: Maybe<TIsolate>,\n): void {\n  if (IsolateInspector.canReorder(newNode)) {\n    return;\n  }\n\n  deferThrow(\n    text(ErrorStrings.TESTS_CALLED_IN_DIFFERENT_ORDER, {\n      fieldName: VestTest.getData(newNode).fieldName,\n      prevName: VestTest.is(prevNode)\n        ? VestTest.getData(prevNode).fieldName\n        : undefined,\n    }),\n  );\n}\n","import { Nullable } from 'vest-utils';\nimport { TIsolate } from 'vestjs-runtime';\n\nimport { IsolateTestReconciler } from 'IsolateTestReconciler';\n\nconst reconcilers: IsolateReconciler[] = [IsolateTestReconciler];\n\nexport function registerReconciler(reconciler: IsolateReconciler) {\n  if (reconcilers.includes(reconciler)) {\n    return;\n  }\n\n  reconcilers.push(reconciler);\n}\n\nexport function VestReconciler(\n  currentNode: TIsolate,\n  historyNode: TIsolate,\n): Nullable<TIsolate> {\n  return (\n    reconcilers\n      .find(reconciler => reconciler.match(currentNode, historyNode))\n      ?.reconcile(currentNode as any, historyNode as any) ?? null\n  );\n}\n\nexport type IsolateReconciler = {\n  match(currentNode: TIsolate, historyNode: TIsolate): boolean;\n  reconcile(elecurrentNode: TIsolate, historyNode: TIsolate): TIsolate;\n};\n","import { TIsolateTest } from 'IsolateTest';\nimport { VestTest } from 'VestTest';\nimport { isSameProfileTest } from 'isSameProfileTest';\n\nexport default function cancelOverriddenPendingTest(\n  prevRunTestObject: TIsolateTest,\n  currentRunTestObject: TIsolateTest,\n): void {\n  if (\n    currentRunTestObject !== prevRunTestObject &&\n    isSameProfileTest(prevRunTestObject, currentRunTestObject) &&\n    VestTest.isPending(prevRunTestObject)\n  ) {\n    VestTest.cancel(prevRunTestObject);\n  }\n}\n","import { CB } from 'vest-utils';\nimport { TIsolate, Isolate } from 'vestjs-runtime';\n\nimport { SuiteContext } from 'SuiteContext';\nimport { TGroupName } from 'SuiteResultTypes';\nimport { VestIsolateType } from 'VestIsolateType';\n\nexport function group<G extends TGroupName>(\n  groupName: G,\n  callback: CB<void>,\n): TIsolate;\nexport function group(callback: CB<void>): TIsolate;\nexport function group<G extends TGroupName>(\n  ...args: [groupName: G, callback: CB<void>] | [callback: CB<void>]\n): TIsolate {\n  const [callback, groupName] = args.reverse() as [CB<void>, G];\n\n  return Isolate.create(VestIsolateType.Group, () => {\n    return SuiteContext.run({ ...(groupName && { groupName }) }, callback);\n  });\n}\n","import { isStringValue, invariant, optionalFunctionValue } from 'vest-utils';\n\nimport { ErrorStrings } from 'ErrorStrings';\nimport { TIsolateTest } from 'IsolateTest';\nimport { useInclusion } from 'SuiteContext';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { TDraftCondition } from 'getTypedMethods';\nimport { useCreateSuiteResult } from 'suiteResult';\nimport { useHasOnliedTests } from 'useHasOnliedTests';\n\n/**\n * Conditionally includes a field for testing, based on specified criteria.\n *\n * @param {string} fieldName - The name of the field to include for testing.\n *\n * @example\n * include('confirm').when('password');\n * // Includes the \"confirm\" field for testing when the \"password\" field is included\n *\n * include('confirm').when(someValue);\n * // Includes the \"confirm\" field for testing when the value of `someValue` is true\n *\n * include('confirm').when(() => someValue);\n * // Includes the \"confirm\" field for testing when the callback function returns true\n *\n * include('username').when(result => result.hasErrors('username'));\n * // Includes the \"username\" field for testing when there are errors associated with it in the current suite result\n */\n// @vx-allow use-use\nexport function include<F extends TFieldName, G extends TGroupName>(\n  fieldName: F,\n): {\n  when: (condition: F | TFieldName | TDraftCondition<F, G>) => void;\n} {\n  invariant(isStringValue(fieldName));\n  const inclusion = useInclusion();\n\n  inclusion[fieldName] = true;\n\n  return { when };\n\n  /**\n   * Specifies the inclusion criteria for the field in `include` function.\n   */\n  function when(condition: F | TFieldName | TDraftCondition<F, G>): void {\n    invariant(condition !== fieldName, ErrorStrings.INCLUDE_SELF);\n\n    const inclusion = useInclusion();\n\n    // This callback will run as part of the \"isExcluded\" series of checks\n    inclusion[fieldName] = function isIncluded(\n      currentNode: TIsolateTest,\n    ): boolean {\n      if (isStringValue(condition)) {\n        return useHasOnliedTests(currentNode, condition);\n      }\n\n      return optionalFunctionValue(\n        condition,\n        optionalFunctionValue(useCreateSuiteResult),\n      );\n    };\n  }\n}\n","import { CB, Maybe } from 'vest-utils';\nimport { TIsolate, Isolate, IsolateKey } from 'vestjs-runtime';\n\nimport { IsolateTestStateMachine, TestStatus } from 'IsolateTestStateMachine';\nimport { TestSeverity } from 'Severity';\nimport { TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { AsyncTest, TestFn } from 'TestTypes';\nimport { VestIsolateType } from 'VestIsolateType';\n\nexport type TIsolateTest<\n  F extends TFieldName = TFieldName,\n  G extends TGroupName = TGroupName,\n> = TIsolate<CommonTestFields<F, G> & IsolateTestPayload>;\n\nexport function IsolateTest<\n  F extends TFieldName = TFieldName,\n  G extends TGroupName = TGroupName,\n>(\n  callback: CB,\n  input: CommonTestFields<F, G>,\n  key?: IsolateKey,\n): TIsolateTest<F, G> {\n  const payload: IsolateTestPayload = {\n    ...IsolateTestBase(),\n    fieldName: input.fieldName,\n    testFn: input.testFn,\n  };\n\n  if (input.groupName) {\n    payload.groupName = input.groupName;\n  }\n\n  if (input.message) {\n    payload.message = input.message;\n  }\n  const isolate = Isolate.create<IsolateTestPayload>(\n    VestIsolateType.Test,\n    callback,\n    payload,\n    key ?? null,\n  );\n\n  return isolate as TIsolateTest<F, G>;\n}\n\nexport function IsolateTestBase() {\n  return {\n    severity: TestSeverity.Error,\n    status: IsolateTestStateMachine.initial(),\n  };\n}\n\nexport type IsolateTestPayload<\n  F extends TFieldName = TFieldName,\n  G extends TGroupName = TGroupName,\n> = CommonTestFields<F, G> & {\n  severity: TestSeverity;\n  status: TestStatus;\n  asyncTest?: AsyncTest;\n};\n\ntype CommonTestFields<\n  F extends TFieldName = TFieldName,\n  G extends TGroupName = TGroupName,\n> = {\n  message?: Maybe<string>;\n  groupName?: G;\n  fieldName: F;\n  testFn: TestFn;\n};\n","import { isPromise, isStringValue, text, deferThrow } from 'vest-utils';\nimport { VestRuntime } from 'vestjs-runtime';\n\nimport { ErrorStrings } from 'ErrorStrings';\nimport { TIsolateTest } from 'IsolateTest';\nimport { SuiteContext } from 'SuiteContext';\nimport { TestResult } from 'TestTypes';\nimport { VestTest } from 'VestTest';\nimport { shouldUseErrorAsMessage } from 'shouldUseErrorMessage';\nimport { useVerifyTestRun } from 'verifyTestRun';\n\n// eslint-disable-next-line max-statements\nexport function useAttemptRunTest(testObject: TIsolateTest) {\n  useVerifyTestRun(testObject);\n\n  if (VestTest.isUntested(testObject)) {\n    return useRunTest(testObject);\n  }\n\n  if (!VestTest.isNonActionable(testObject)) {\n    // Probably unreachable. If we get here, it means that\n    // something was really wrong and should be reported.\n    /* istanbul ignore next */\n    deferThrow(\n      text(ErrorStrings.UNEXPECTED_TEST_REGISTRATION_ERROR, {\n        testObject: JSON.stringify(testObject),\n      }),\n    );\n  }\n}\n\nfunction runSyncTest(testObject: TIsolateTest): TestResult {\n  return SuiteContext.run({ currentTest: testObject }, () => {\n    let result: TestResult;\n\n    const { message, testFn } = VestTest.getData(testObject);\n\n    try {\n      result = testFn({ signal: testObject.abortController.signal });\n    } catch (error) {\n      if (shouldUseErrorAsMessage(message, error)) {\n        VestTest.getData(testObject).message = error;\n      }\n      result = false;\n    }\n\n    if (result === false) {\n      VestTest.fail(testObject);\n    }\n\n    return result;\n  });\n}\n\n/**\n * runs test, if async - adds to pending array\n */\nfunction useRunTest(testObject: TIsolateTest): Promise<void> | undefined {\n  // Run test callback.\n  // If a promise is returned, set as async and\n  // Move to pending list.\n  const result = runSyncTest(testObject);\n  try {\n    // try catch for safe property access\n    // in case object is an enforce chain\n    if (isPromise(result)) {\n      VestTest.getData(testObject).asyncTest = result;\n      return useRunAsyncTest(testObject);\n    }\n\n    onTestCompleted(testObject);\n  } catch (e) {\n    // Probably unreachable. If we get here, it means that\n    // something was really wrong and should be reported.\n    /* istanbul ignore next */\n    throw new Error(\n      text(ErrorStrings.UNEXPECTED_TEST_REGISTRATION_ERROR, {\n        testObject: JSON.stringify(testObject),\n        error: e,\n      }),\n    );\n  }\n}\n\n/**\n * Runs async test.\n */\nfunction useRunAsyncTest(testObject: TIsolateTest): Promise<void> | undefined {\n  const { asyncTest, message } = VestTest.getData(testObject);\n\n  if (!isPromise(asyncTest)) return;\n  // VestTest.setPending(testObject);\n\n  const done = VestRuntime.persist(() => {\n    onTestCompleted(testObject);\n  });\n  const fail = VestRuntime.persist((rejectionMessage?: string) => {\n    if (VestTest.isCanceled(testObject)) {\n      return;\n    }\n\n    VestTest.getData(testObject).message = isStringValue(rejectionMessage)\n      ? rejectionMessage\n      : message;\n    VestTest.fail(testObject);\n\n    done();\n  });\n\n  return asyncTest.then(done, fail);\n}\n\nfunction onTestCompleted(testObject: TIsolateTest) {\n  // Attempts passing if the test is not already failed.\n  // or is not canceled/omitted.\n  VestTest.pass(testObject);\n}\n","import { Maybe, isStringValue, isUndefined } from 'vest-utils';\n\nexport function shouldUseErrorAsMessage(\n  message: Maybe<string>,\n  error: unknown,\n): error is Maybe<string> {\n  // kind of cheating with this safe guard, but it does the job\n  return isUndefined(message) && isStringValue(error);\n}\n","import { assign, invariant, isFunction, isStringValue, text } from 'vest-utils';\nimport { Bus, IsolateKey } from 'vestjs-runtime';\n\nimport { ErrorStrings } from 'ErrorStrings';\nimport { IsolateTest, TIsolateTest } from 'IsolateTest';\nimport { useGroupName } from 'SuiteContext';\nimport { TFieldName } from 'SuiteResultTypes';\nimport { TestFn } from 'TestTypes';\nimport { useAttemptRunTest } from 'runTest';\nimport { wrapTestMemo } from 'test.memo';\n\nfunction vestTest<F extends TFieldName>(\n  fieldName: F,\n  message: string,\n  cb: TestFn,\n): TIsolateTest;\nfunction vestTest<F extends TFieldName>(fieldName: F, cb: TestFn): TIsolateTest;\nfunction vestTest<F extends TFieldName>(\n  fieldName: F,\n  message: string,\n  cb: TestFn,\n  key: IsolateKey,\n): TIsolateTest;\nfunction vestTest<F extends TFieldName>(\n  fieldName: F,\n  cb: TestFn,\n  key: IsolateKey,\n): TIsolateTest;\n// @vx-allow use-use\nfunction vestTest<F extends TFieldName>(\n  fieldName: F,\n  ...args:\n    | [message: string, cb: TestFn]\n    | [cb: TestFn]\n    | [message: string, cb: TestFn, key: IsolateKey]\n    | [cb: TestFn, key: IsolateKey]\n): TIsolateTest {\n  const [message, testFn, key] = (\n    isFunction(args[1]) ? args : [undefined, ...args]\n  ) as [string, TestFn, IsolateKey];\n\n  validateTestParams(fieldName, testFn);\n\n  const groupName = useGroupName();\n\n  const testObjectInput = { fieldName, groupName, message, testFn };\n\n  // This invalidates the suite cache.\n  Bus.useEmit('TEST_RUN_STARTED');\n\n  return IsolateTest(useAttemptRunTest, testObjectInput, key);\n}\n\nexport const test = assign(vestTest, {\n  memo: wrapTestMemo(vestTest),\n});\n\nexport type VTest = typeof vestTest;\n\nfunction validateTestParams(fieldName: string, testFn: TestFn): void {\n  const fnName = 'test';\n  invariant(\n    isStringValue(fieldName),\n    text(ErrorStrings.INVALID_PARAM_PASSED_TO_FUNCTION, {\n      fn_name: fnName,\n      param: 'fieldName',\n      expected: 'string',\n    }),\n  );\n  invariant(\n    isFunction(testFn),\n    text(ErrorStrings.INVALID_PARAM_PASSED_TO_FUNCTION, {\n      fn_name: fnName,\n      param: 'callback',\n      expected: 'function',\n    }),\n  );\n}\n","import { CB, isNull } from 'vest-utils';\nimport { VestRuntime } from 'vestjs-runtime';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport * as Runtime from 'Runtime';\nimport { useTestMemoCache } from 'SuiteContext';\nimport { TFieldName } from 'SuiteResultTypes';\nimport { TestFn } from 'TestTypes';\nimport { VestTest } from 'VestTest';\nimport { VTest } from 'test';\n\n// @vx-allow use-use\nexport function wrapTestMemo<FN extends TFieldName>(test: VTest): TestMemo<FN> {\n  /**\n   * Caches a test result based on the test's dependencies.\n   */\n  function memo<F extends FN>(\n    fieldName: F,\n    ...args: ParametersWithoutMessage\n  ): TIsolateTest;\n  function memo<F extends FN>(\n    fieldName: F,\n    ...args: ParametersWithMessage\n  ): TIsolateTest;\n  function memo<F extends FN>(\n    fieldName: F,\n    ...args: ParamsOverload\n  ): TIsolateTest {\n    const [deps, testFn, msg] = args.reverse() as [any[], TestFn, string];\n\n    // Implicit dependency for better specificity\n    const dependencies = [\n      Runtime.useSuiteId(),\n      fieldName,\n      VestRuntime.useCurrentCursor(),\n    ].concat(deps);\n\n    return useGetTestFromCache(dependencies, cacheAction);\n\n    function cacheAction() {\n      return test(fieldName, msg, testFn);\n    }\n  }\n\n  return memo;\n}\n\nfunction useGetTestFromCache(\n  dependencies: any[],\n  cacheAction: CB<TIsolateTest>,\n): TIsolateTest {\n  const cache = useTestMemoCache();\n\n  const cached = cache.get(dependencies);\n\n  if (isNull(cached)) {\n    // cache miss\n    return cache(dependencies, cacheAction);\n  }\n\n  const [, cachedValue] = cached;\n\n  if (VestTest.isCanceled(cachedValue)) {\n    // cache hit, but test is canceled\n    cache.invalidate(dependencies);\n    return cache(dependencies, cacheAction);\n  }\n\n  // FIXME:(@ealush 2024-08-12): This is some kind of a hack. Instead organically letting Vest set the next\n  // child of the isolate, we're forcing it from the outside.\n  // Instead, an ideal solution would probably be to have test.memo be its own isolate\n  // that just injects a historic output from a previous test run.\n  VestRuntime.useSetNextIsolateChild(cachedValue);\n\n  return cachedValue;\n}\n\nexport type TestMemo<F extends TFieldName> = {\n  (fieldName: F, ...args: ParametersWithoutMessage): TIsolateTest;\n  (fieldName: F, ...args: ParametersWithMessage): TIsolateTest;\n};\n\ntype ParametersWithoutMessage = [test: TestFn, dependencies: unknown[]];\ntype ParametersWithMessage = [\n  message: string,\n  test: TestFn,\n  dependencies: unknown[],\n];\n\ntype ParamsOverload = ParametersWithoutMessage | ParametersWithMessage;\n","// import { optional, skipWhen, omitWhen, IsolateTest, group } from 'vest';\nimport { optional } from 'optional';\nimport { CB, DynamicValue } from 'vest-utils';\nimport { TIsolate, IsolateKey } from 'vestjs-runtime';\n\nimport { TIsolateTest } from 'IsolateTest';\nimport { OptionalsInput } from 'OptionalTypes';\nimport { SuiteResult, TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { TestFn } from 'TestTypes';\nimport { FieldExclusion, only, skip } from 'focused';\nimport { group } from 'group';\nimport { include } from 'include';\nimport { omitWhen } from 'omitWhen';\nimport { skipWhen } from 'skipWhen';\nimport { test } from 'test';\nimport { TestMemo } from 'test.memo';\n\nexport function getTypedMethods<\n  F extends TFieldName,\n  G extends TGroupName,\n>(): TTypedMethods<F, G> {\n  return {\n    group,\n    include,\n    omitWhen,\n    only,\n    optional,\n    skip,\n    skipWhen,\n    test,\n  };\n}\n\nexport type TTypedMethods<F extends TFieldName, G extends TGroupName> = {\n  include: (fieldName: F) => {\n    when: (condition: F | TDraftCondition<F, G>) => void;\n  };\n  omitWhen: (conditional: TDraftCondition<F, G>, callback: CB) => void;\n  only: {\n    (item: FieldExclusion<F>): void;\n  };\n  optional: (optionals: OptionalsInput<F>) => void;\n  skip: {\n    (item: FieldExclusion<F>): void;\n  };\n  skipWhen: (condition: TDraftCondition<F, G>, callback: CB) => void;\n  test: {\n    (fieldName: F, message: string, cb: TestFn): TIsolateTest;\n    (fieldName: F, cb: TestFn): TIsolateTest;\n    (fieldName: F, message: string, cb: TestFn, key: IsolateKey): TIsolateTest;\n    (fieldName: F, cb: TestFn, key: IsolateKey): TIsolateTest;\n  } & {\n    memo: TestMemo<F>;\n  };\n  group: {\n    (callback: () => void): TIsolate;\n    (groupName: G, callback: () => void): TIsolate;\n  };\n};\n\nexport type TDraftCondition<\n  F extends TFieldName,\n  G extends TGroupName,\n> = DynamicValue<boolean, [draft: SuiteResult<F, G>]>;\n","import { isEmpty, optionalFunctionValue } from 'vest-utils';\nimport { Bus, VestRuntime } from 'vestjs-runtime';\n\nimport { SuiteOptionalFields, TIsolateSuite } from 'IsolateSuite';\nimport { TIsolateTest } from 'IsolateTest';\nimport { TestWalker } from 'TestWalker';\nimport { VestTest } from 'VestTest';\n\n/**\n * This module gets triggered once the suite is done running its sync tests.\n *\n * It goes over all the tests in the state, and checks if they need to be omitted.\n */\n\nexport function useOmitOptionalFields(): void {\n  const root = VestRuntime.useAvailableRoot<TIsolateSuite>();\n\n  const optionalFields = SuiteOptionalFields.getOptionalFields(root);\n\n  // If there are no optional fields, we don't need to do anything\n  if (isEmpty(optionalFields)) {\n    return;\n  }\n\n  // Create an object to store the fields that need to be omitted\n  const shouldOmit = new Set<string>();\n\n  // iterate over each of the tests in the state\n  TestWalker.walkTests(testObject => {\n    if (VestTest.isPending(testObject)) {\n      return;\n    }\n    const { fieldName } = VestTest.getData(testObject);\n\n    // If we already added the current field (not this test specifically)\n    // no need for further checks, go and omit the test\n    if (shouldOmit.has(fieldName)) {\n      verifyAndOmit(testObject);\n    } else {\n      // check if the field has an optional function\n      // if so, run it and verify/omit the test\n      runOptionalConfig(testObject);\n    }\n  });\n\n  Bus.useEmit('DONE_TEST_OMISSION_PASS');\n\n  function verifyAndOmit(testObject: TIsolateTest) {\n    const { fieldName } = VestTest.getData(testObject);\n    if (shouldOmit.has(fieldName)) {\n      VestTest.omit(testObject);\n      SuiteOptionalFields.setOptionalField(root, fieldName, current => ({\n        ...current,\n        applied: true,\n      }));\n    }\n  }\n\n  function runOptionalConfig(testObject: TIsolateTest) {\n    const { fieldName } = VestTest.getData(testObject);\n\n    // Ge the optional configuration for the given field\n    const optionalConfig = SuiteOptionalFields.getOptionalField(\n      root,\n      fieldName,\n    );\n\n    // If the optional was set to a function or a boolean, run it and verify/omit the test\n    if (optionalFunctionValue(optionalConfig.rule) === true) {\n      shouldOmit.add(fieldName);\n    }\n\n    verifyAndOmit(testObject);\n  }\n}\n","import { CB, ValueOf } from 'vest-utils';\nimport { Bus, RuntimeEvents, TIsolate } from 'vestjs-runtime';\n\nimport { Events } from 'BusEvents';\n// import { TIsolateTest } from 'IsolateTest';\nimport {\n  useExpireSuiteResultCache,\n  useResetCallbacks,\n  useResetSuite,\n} from 'Runtime';\nimport { TFieldName } from 'SuiteResultTypes';\nimport { SuiteWalker } from 'SuiteWalker';\nimport { TestWalker } from 'TestWalker';\nimport { VestIsolate } from 'VestIsolate';\nimport { VestTest } from 'VestTest';\nimport { useOmitOptionalFields } from 'omitOptionalFields';\nimport { useRunDoneCallbacks, useRunFieldCallbacks } from 'runCallbacks';\n\n// eslint-disable-next-line max-statements, max-lines-per-function\nexport function useInitVestBus() {\n  const VestBus = Bus.useBus();\n\n  on('TEST_COMPLETED', () => {});\n\n  on('TEST_RUN_STARTED', () => {\n    // Bringin this back due to https://github.com/ealush/vest/issues/1157\n    // This is a very pecluiar bug in which we're seeing vest behaving differently between\n    // runs when suite.get() is called.\n    // In the bug we experienced that failing tests were skipped in the second run.\n    // The reason: suite.get() built the failures cache. Calling suite.get() before the test run\n    // made Vest think that the field already had failing tests (even though it was the same test!)\n    // and it skipped the test.\n    // A better solution is to be able to identify each failure to its actual position in the suite\n    // but this requires some rearchitecting within Vest.\n    // This is an easy enough solution - we just reset the cache before the test run, let's hope we don't see\n    // any performance issues.\n  });\n\n  VestBus.on(RuntimeEvents.ISOLATE_PENDING, (isolate: TIsolate) => {\n    if (VestTest.is(isolate)) {\n      VestTest.setPending(isolate);\n    }\n\n    VestIsolate.setPending(isolate);\n  });\n\n  VestBus.on(RuntimeEvents.ISOLATE_DONE, (isolate: TIsolate) => {\n    if (VestTest.is(isolate)) {\n      VestBus.emit('TEST_COMPLETED', isolate);\n    }\n\n    VestIsolate.setDone(isolate);\n  });\n\n  VestBus.on(RuntimeEvents.ASYNC_ISOLATE_DONE, (isolate: TIsolate) => {\n    if (VestTest.is(isolate)) {\n      if (!VestTest.isCanceled(isolate)) {\n        const { fieldName } = VestTest.getData(isolate);\n\n        useRunFieldCallbacks(fieldName);\n      }\n    }\n\n    if (!SuiteWalker.useHasPending()) {\n      // When no more async tests are running, emit the done event\n      VestBus.emit('ALL_RUNNING_TESTS_FINISHED');\n    }\n  });\n\n  on('DONE_TEST_OMISSION_PASS', () => {\n    /* We NEED to refresh the cache here. Don't ask */\n  });\n\n  // Called when all the tests, including async, are done running\n  VestBus.on('ALL_RUNNING_TESTS_FINISHED', () => {\n    // Small optimization. We don't need to run this if there are no async tests\n    // The reason is that we run this function immediately after the suite callback\n    // is run, so if the suite is only comprised of sync tests, we don't need to\n    // run this function twice since we know for a fact the state is up to date\n    if (TestWalker.someTests(VestTest.isAsyncTest)) {\n      useOmitOptionalFields();\n    }\n    useRunDoneCallbacks();\n  });\n\n  on('RESET_FIELD', (fieldName: TFieldName) => {\n    TestWalker.resetField(fieldName);\n  });\n\n  on('SUITE_RUN_STARTED', () => {\n    useResetCallbacks();\n  });\n\n  on('SUITE_CALLBACK_RUN_FINISHED', () => {\n    if (!SuiteWalker.useHasPending()) {\n      // When no more async tests are running, emit the done event\n      VestBus.emit('ALL_RUNNING_TESTS_FINISHED');\n    }\n\n    useOmitOptionalFields();\n  });\n\n  on('REMOVE_FIELD', (fieldName: TFieldName) => {\n    TestWalker.removeTestByFieldName(fieldName);\n  });\n\n  on('RESET_SUITE', () => {\n    useResetSuite();\n  });\n\n  return {\n    subscribe,\n  };\n\n  function subscribe(event: Events, cb: CB): CB<void>;\n  function subscribe(cb: CB): CB<void>;\n  function subscribe(...args: [event: Events, cb: CB] | [cb: CB]): CB<void> {\n    const [cb, event] = args.reverse() as [CB, Events];\n    return VestBus.on(event ?? '*', () => {\n      cb();\n    }).off;\n  }\n\n  function on(event: VestEvents, cb: (...args: any[]) => void) {\n    VestBus.on(event, (...args: any[]) => {\n      // This is more concise, but it might be an overkill\n      // if we're adding events that don't need to invalidate the cache\n      useExpireSuiteResultCache();\n      cb(...args);\n    });\n  }\n}\n\ntype VestEvents = Events | ValueOf<typeof RuntimeEvents> | '*';\n\nexport type Subscribe = {\n  (event: Events, cb: CB): CB<void>;\n  (cb: CB): CB<void>;\n};\n","import { isArray, callEach } from 'vest-utils';\n\nimport { useDoneCallbacks, useFieldCallbacks } from 'Runtime';\nimport { TFieldName } from 'SuiteResultTypes';\nimport { SuiteWalker } from 'SuiteWalker';\n\n/**\n * Runs done callback per field when async tests are finished running.\n */\nexport function useRunFieldCallbacks(fieldName?: TFieldName): void {\n  const [fieldCallbacks] = useFieldCallbacks();\n\n  if (\n    fieldName &&\n    !SuiteWalker.useHasRemainingWithTestNameMatching(fieldName) &&\n    isArray(fieldCallbacks[fieldName])\n  ) {\n    callEach(fieldCallbacks[fieldName]);\n  }\n}\n\n/**\n * Runs unlabelled done callback when async tests are finished running.\n */\nexport function useRunDoneCallbacks() {\n  const [doneCallbacks] = useDoneCallbacks();\n  callEach(doneCallbacks);\n}\n","import { freezeAssign } from 'vest-utils';\nimport { VestRuntime } from 'vestjs-runtime';\n\nimport {\n  SuiteResult,\n  SuiteRunResult,\n  TFieldName,\n  TGroupName,\n} from 'SuiteResultTypes';\nimport { SuiteWalker } from 'SuiteWalker';\nimport { useDeferDoneCallback } from 'deferDoneCallback';\nimport { shouldSkipDoneRegistration } from 'shouldSkipDoneRegistration';\nimport { useCreateSuiteResult } from 'suiteResult';\n\nexport function useSuiteRunResult<\n  F extends TFieldName,\n  G extends TGroupName,\n>(): SuiteRunResult<F, G> {\n  return freezeAssign<SuiteRunResult<F, G>>(\n    {\n      done: VestRuntime.persist(done) as Done<F, G>,\n    },\n    useCreateSuiteResult<F, G>(),\n  );\n}\n\n/**\n * Registers done callbacks.\n * @register {Object} Vest output object.\n */\n// @vx-allow use-use\nfunction done<F extends TFieldName, G extends TGroupName>(\n  ...args: any[]\n): SuiteRunResult<F, G> {\n  const [callback, fieldName] = args.reverse() as [\n    (res: SuiteResult<F, G>) => void,\n    F,\n  ];\n  const output = useSuiteRunResult<F, G>();\n  if (shouldSkipDoneRegistration<F, G>(callback, fieldName, output)) {\n    return output;\n  }\n  const useDoneCallback = () => callback(useCreateSuiteResult());\n  if (!SuiteWalker.useHasRemainingWithTestNameMatching(fieldName)) {\n    useDoneCallback();\n    return output;\n  }\n  useDeferDoneCallback(useDoneCallback, fieldName);\n  return output;\n}\n\nexport interface Done<F extends TFieldName, G extends TGroupName> {\n  (...args: [cb: (res: SuiteResult<F, G>) => void]): SuiteRunResult<F, G>;\n  (\n    ...args: [fieldName: F, cb: (res: SuiteResult<F, G>) => void]\n  ): SuiteRunResult<F, G>;\n}\n","/**\n * DONE is here and not in its own module to prevent circular dependency issues.\n */\n\nimport { Maybe, isFunction, numberEquals } from 'vest-utils';\n\nimport {\n  SuiteResult,\n  SuiteRunResult,\n  TFieldName,\n  TGroupName,\n} from 'SuiteResultTypes';\n\nexport function shouldSkipDoneRegistration<\n  F extends TFieldName,\n  G extends TGroupName,\n>(\n  callback: (res: SuiteResult<F, G>) => void,\n\n  fieldName: Maybe<F>,\n  output: SuiteRunResult<F, G>,\n): boolean {\n  // If we do not have any test runs for the current field\n  return !!(\n    !isFunction(callback) ||\n    (fieldName && numberEquals(output.tests[fieldName]?.testCount ?? 0, 0))\n  );\n}\n","import { assign } from 'vest-utils';\n\nimport { DoneCallback, useDoneCallbacks, useFieldCallbacks } from 'Runtime';\nimport { TFieldName } from 'SuiteResultTypes';\n\nexport function useDeferDoneCallback(\n  doneCallback: DoneCallback,\n  fieldName?: TFieldName,\n): void {\n  const [, setFieldCallbacks] = useFieldCallbacks();\n  const [, setDoneCallbacks] = useDoneCallbacks();\n\n  if (fieldName) {\n    setFieldCallbacks(fieldCallbacks =>\n      assign(fieldCallbacks, {\n        [fieldName]: (fieldCallbacks[fieldName] || []).concat(doneCallback),\n      }),\n    );\n\n    return;\n  }\n\n  setDoneCallbacks(doneCallbacks => doneCallbacks.concat(doneCallback));\n}\n","import { asArray, assign, CB } from 'vest-utils';\nimport { Bus, VestRuntime } from 'vestjs-runtime';\n\nimport { TTypedMethods, getTypedMethods } from './getTypedMethods';\n\nimport { IsolateSuite, TIsolateSuite } from 'IsolateSuite';\nimport { useCreateVestState, useLoadSuite } from 'Runtime';\nimport { SuiteContext } from 'SuiteContext';\nimport {\n  SuiteName,\n  SuiteResult,\n  SuiteRunResult,\n  TFieldName,\n  TGroupName,\n} from 'SuiteResultTypes';\nimport { Suite } from 'SuiteTypes';\nimport { useInitVestBus } from 'VestBus';\nimport { VestReconciler } from 'VestReconciler';\nimport { useCreateSuiteResult } from 'suiteResult';\nimport { useSuiteRunResult } from 'suiteRunResult';\nimport { bindSuiteSelectors } from 'suiteSelectors';\nimport { validateSuiteCallback } from 'validateSuiteParams';\n\nfunction createSuite<\n  F extends TFieldName = string,\n  G extends TGroupName = string,\n  T extends CB = CB,\n>(suiteName: SuiteName, suiteCallback: T): Suite<F, G, T>;\nfunction createSuite<\n  F extends TFieldName = string,\n  G extends TGroupName = string,\n  T extends CB = CB,\n>(suiteCallback: T): Suite<F, G, T>;\n// @vx-allow use-use\n// eslint-disable-next-line max-lines-per-function\nfunction createSuite<\n  F extends TFieldName = string,\n  G extends TGroupName = string,\n  T extends CB = CB,\n>(\n  ...args: [suiteName: SuiteName, suiteCallback: T] | [suiteCallback: T]\n): Suite<F, G, T> {\n  const [suiteCallback, suiteName] = asArray(args).reverse() as [T, SuiteName];\n\n  validateSuiteCallback(suiteCallback);\n\n  // Create a stateRef for the suite\n  // It holds the suite's persisted values that may remain between runs.\n  const stateRef = useCreateVestState({ suiteName, VestReconciler });\n\n  function suite(...args: Parameters<T>): SuiteRunResult<F, G> {\n    return SuiteContext.run(\n      {\n        suiteParams: args,\n      },\n      () => {\n        Bus.useEmit('SUITE_RUN_STARTED');\n\n        return IsolateSuite(\n          useRunSuiteCallback<T, F, G>(suiteCallback, ...args),\n        );\n      },\n    ).output;\n  }\n\n  const mountedStatic = staticSuite<F, G, T>(...(args as [T]));\n\n  // Assign methods to the suite\n  // We do this within the VestRuntime so that the suite methods\n  // will be bound to the suite's stateRef and be able to access it.\n  return VestRuntime.Run(stateRef, () => {\n    // @vx-allow use-use\n    const VestBus = useInitVestBus();\n\n    return assign(\n      // We're also binding the suite to the stateRef, so that the suite\n      // can access the stateRef when it's called.\n      VestRuntime.persist(suite),\n      {\n        dump: VestRuntime.persist(\n          () => VestRuntime.useAvailableRoot() as TIsolateSuite,\n        ),\n        get: VestRuntime.persist(useCreateSuiteResult),\n        remove: Bus.usePrepareEmitter<string>('REMOVE_FIELD'),\n        reset: Bus.usePrepareEmitter('RESET_SUITE'),\n        resetField: Bus.usePrepareEmitter<string>('RESET_FIELD'),\n        resume: VestRuntime.persist(useLoadSuite),\n        runStatic: (...args: Parameters<T>): StaticSuiteRunResult<F, G> =>\n          mountedStatic(...args) as StaticSuiteRunResult<F, G>,\n        subscribe: VestBus.subscribe,\n        ...bindSuiteSelectors<F, G>(VestRuntime.persist(useCreateSuiteResult)),\n        ...getTypedMethods<F, G>(),\n      },\n    );\n  });\n}\n\nfunction useRunSuiteCallback<\n  T extends CB,\n  F extends TFieldName,\n  G extends TGroupName,\n>(suiteCallback: T, ...args: Parameters<T>): CB<SuiteRunResult<F, G>> {\n  const emit = Bus.useEmit();\n\n  return () => {\n    suiteCallback(...args);\n    emit('SUITE_CALLBACK_RUN_FINISHED');\n    return useSuiteRunResult<F, G>();\n  };\n}\n\n/**\n * Creates a static suite for server-side validation.\n *\n * @param {Function} validationFn - The validation function that defines the suite's tests.\n * @returns {Function} - A function that runs the validations defined in the suite.\n *\n * @example\n * import { staticSuite, test, enforce } from 'vest';\n *\n * const suite = staticSuite(data => {\n *   test('username', 'username is required', () => {\n *     enforce(data.username).isNotEmpty();\n *   });\n * });\n *\n * suite(data);\n */\n\nfunction staticSuite<\n  F extends TFieldName = string,\n  G extends TGroupName = string,\n  T extends CB = CB,\n>(suiteName: SuiteName, suiteCallback: T): StaticSuite<F, G, T>;\nfunction staticSuite<\n  F extends TFieldName = string,\n  G extends TGroupName = string,\n  T extends CB = CB,\n>(suiteCallback: T): StaticSuite<F, G, T>;\n// @vx-allow use-use\n// eslint-disable-next-line max-lines-per-function\nfunction staticSuite<\n  F extends TFieldName = string,\n  G extends TGroupName = string,\n  T extends CB = CB,\n>(\n  ...createArgs: [suiteName: SuiteName, suiteCallback: T] | [suiteCallback: T]\n): StaticSuite<F, G, T> {\n  return assign(\n    (...args: Parameters<T>): StaticSuiteRunResult<F, G> => {\n      const suite = createSuite<F, G, T>(\n        ...(createArgs as unknown as [SuiteName, T]),\n      );\n\n      const result = suite(...args);\n\n      return assign(\n        new Promise<SuiteWithDump<F, G>>(resolve => {\n          result.done(res => {\n            resolve(withDump(res) as SuiteWithDump<F, G>);\n          });\n        }),\n        withDump(result),\n      );\n\n      function withDump(o: any) {\n        return assign({ dump: suite.dump }, o);\n      }\n    },\n    {\n      ...getTypedMethods<F, G>(),\n    },\n  );\n}\n\nexport type StaticSuite<\n  F extends TFieldName = string,\n  G extends TGroupName = string,\n  T extends CB = CB,\n> = (...args: Parameters<T>) => StaticSuiteRunResult<F, G>;\n\nexport type StaticSuiteRunResult<\n  F extends TFieldName = string,\n  G extends TGroupName = string,\n> = Promise<SuiteWithDump<F, G>> &\n  WithDump<SuiteRunResult<F, G> & TTypedMethods<F, G>>;\n\ntype WithDump<T> = T & { dump: CB<TIsolateSuite> };\ntype SuiteWithDump<F extends TFieldName, G extends TGroupName> = WithDump<\n  SuiteResult<F, G>\n>;\n\nexport { createSuite, staticSuite };\n","import { CB, invariant, isFunction } from 'vest-utils';\n\nimport { ErrorStrings } from 'ErrorStrings';\n\nexport function validateSuiteCallback<T extends CB>(\n  suiteCallback: T,\n): asserts suiteCallback is T {\n  invariant(\n    isFunction(suiteCallback),\n    ErrorStrings.SUITE_MUST_BE_INITIALIZED_WITH_FUNCTION,\n  );\n}\n","import { invariant } from 'vest-utils';\n\nimport { ErrorStrings } from 'ErrorStrings';\nimport { useCurrentTest } from 'SuiteContext';\nimport { VestTest } from 'VestTest';\n\nconst ERROR_OUTSIDE_OF_TEST = ErrorStrings.WARN_MUST_BE_CALLED_FROM_TEST;\n\n/**\n * Sets the severity level of a test to `warn`, allowing it to fail without marking the suite as invalid.\n * Use this function within the body of a test to create warn-only tests.\n *\n * @returns {void}\n *\n * @example\n *   test('password', 'Your password strength is: WEAK', () => {\n *     warn();\n *\n *     enforce(data.password).matches(/0-9/);\n *   });\n *\n * @limitations\n * - The `warn` function should only be used within the body of a `test` function.\n * - When using `warn()` in an async test, it should be called in the synchronous portion of the test, not after an `await` call or in the Promise body.\n * - It is recommended to call `warn()` at the top of the test function.\n */\n// @vx-allow use-use\nexport function warn(): void {\n  const currentTest = useCurrentTest(ErrorStrings.HOOK_CALLED_OUTSIDE);\n\n  invariant(currentTest, ERROR_OUTSIDE_OF_TEST);\n\n  VestTest.warn(currentTest);\n}\n","import { invariant, isFunction } from 'vest-utils';\n\nimport { ErrorStrings } from 'ErrorStrings';\nimport { IsolateEach } from 'IsolateEach';\n\n/**\n * Iterates over an array of items, allowing to run tests individually per item.\n *\n * Requires setting a \"key\" property on each item tested.\n *\n * @example\n *\n * each(itemsArray, (item) => {\n *  test(item.name, 'Item value must not be empty', () => {\n *    enforce(item.value).isNotEmpty();\n *  }, item.id)\n * })\n */\nexport function each<T>(\n  list: T[],\n  callback: (arg: T, index: number) => void,\n): void {\n  invariant(\n    isFunction(callback),\n    ErrorStrings.EACH_CALLBACK_MUST_BE_A_FUNCTION,\n  );\n\n  IsolateEach(() => {\n    list.forEach((arg, index) => {\n      callback(arg, index);\n    });\n  });\n}\n","import { CB } from 'vest-utils';\nimport { TIsolate, Isolate } from 'vestjs-runtime';\n\nimport { VestIsolateType } from 'VestIsolateType';\n\ntype TIsolateEach = TIsolate;\n\nexport function IsolateEach<Callback extends CB = CB>(\n  callback: Callback,\n): TIsolateEach {\n  return Isolate.create(VestIsolateType.Each, callback, {\n    allowReorder: true,\n  });\n}\n"],"names":["VestIsolateType","Each","Focused","Group","OmitWhen","SkipWhen","Suite","Test","SuiteOptionalFields","setOptionalField","suite","fieldName","setter","current","data","optional","currentField","assign","getOptionalField","_a","getOptionalFields","_b","OptionalFieldTypes","Modes","exports","SuiteContext","createCascade","ctxRef","parentContext","inclusion","mode","tinyState","createTinyState","EAGER","suiteParams","testMemoCache","useInclusion","useX","useMode","cache","optionals","suiteRoot","VestRuntime","useAvailableRoot","dataObject","isArray","isStringValue","asArray","forEach","optionalField","type","AUTO","applied","hasOwnProperty","enforce","isBlank","test","rule","field","value","CUSTOM_LOGIC","useIsOptionalFieldApplied","root","ErrorStrings","CommonStates","State","CommonStates_PENDING","CommonStates_INITIAL","CommonStates_DONE","machine","initial","INITIAL","states","DONE","PENDING","CommonStateMachine","StateMachine","TestStatus","CANCELED","FAILED","OMITTED","PASSING","SKIPPED","UNTESTED","WARNING","TestAction","TestAction_RESET","force","IsolateTestStateMachine","Severity","SeverityCount","TestSeverity","FocusModes","countKeyBySeverity","severity","ERRORS","ERROR_COUNT","WARN_COUNT","VestIsolate","getStatus","isolate","status","setStatus","payload","this","stateMachine","staticTransition","statusEquals","setPending","setDone","isPending","VestTest","getData","invariant","is","IsolateSelectors","isIsolateType","isX","EXPECTED_VEST_TEST","cast","warns","Warning","isOmitted","isUntested","isFailing","isCanceled","isSkipped","isPassing","isWarning","hasFailures","isNonActionable","isTested","awaitsResolution","isAsyncTest","isPromise","asyncTest","fail","pass","warn","setData","optionalFunctionValue","skip","cancel","IsolateMutator","abort","omit","reset","nonMatchingFieldName","WithFieldName","matchingFieldName","isSameProfileTest","testObject1","testObject2","groupName","gn1","gn2","fn2","key","IsolateFocused","focusMode","match","Isolate","create","noop","filter","matchAll","FocusSelectors","isSkipFocused","focus","SKIP","hasFocus","isOnlyFocused","ONLY","isIsolateFocused","only","defaultMatch","isNotEmpty","includes","SummaryBase","constructor","errorCount","warnCount","testCount","pendingCount","SuiteSummary","groups","tests","valid","WARNINGS","suiteResultCache","preAggCache","useXAppData","useDoneCallbacks","doneCallbacks","useFieldCallbacks","fieldCallbacks","useSuiteId","suiteId","useExpireSuiteResultCache","invalidate","useResetCallbacks","resetDoneCallbacks","resetFieldCallbacks","useLoadSuite","rootNode","useSetHistoryRoot","gatherFailures","testGroup","severityKey","getByFieldName","output","countKey","isPositive","collectAll","suiteSelectors","summary","selectors","getError","getErrors","getFailures","getErrorsByGroup","getFailuresByGroup","getMessage","getWarning","getWarnings","getWarningsByGroup","hasErrors","hasErrorsByGroup","hasFailuresByGroup","hasWarnings","hasWarningsByGroup","greaterThan","isValid","Boolean","isValidByGroup","group","isFieldValid","getFailure","testContainer","severityCount","failureCount","summaryKey","find","summaryFailure","message","SummaryFailure","fromTestObject","testObject","TestWalker","hasNoTests","defaultRoot","Walker","has","someTests","predicate","some","everyTest","every","walkTests","callback","walk","breakout","reduceTests","initialValue","reduce","acc","pluckTests","pluck","resetField","removeTestByFieldName","SuiteWalker","useHasPending","allPending","usePreAggs","pending","isEmpty","Predicates","all","action","buildPreAggCache","useHasRemainingWithTestNameMatching","any","isNullish","matchesOrHasNoFieldName","base","failures","errors","warnings","agg","push","nonMatchingGroupName","bindNot","hasErrorsByTestObjects","allFailures","hasFailuresByTestObjects","hasGroupFailuresByTestObjects","either","nonMatchingSeverityProfile","hasFailuresByTestObject","useShouldAddValidProperty","useHasNonOptionalIncomplete","useNoMissingTestsLogic","useNoMissingTests","useShouldAddValidPropertyInGroup","useHasNonOptionalIncompleteByGroup","useNoMissingTestsByGroup","useOptionalTestAwaitsResolution","useProduceSuiteSummary","appendTestObject","useAppendToTest","useAppendToGroup","shouldCountTestRun","addSummaryStats","nextSummaryKey","defaultTo","Object","baseTestStats","incrementFailures","concat","useCreateSuiteResult","suiteName","freeze","constructSuiteResultObject","LazyDraft","emptySummary","Proxy","get","_","prop","skipWhen","condition","run","skipped","useIsExcludedIndividually","useSkipped","useHasOnliedTests","isNotNullish","findClosest","child","useIsExcluded","focusMatch","useClosestMatchingFocus","useIsMode","currentMode","useShouldSkipBasedOnMode","testData","ONE","omitWhen","conditional","omitted","useWithinActiveOmitWhen","useOmitted","useVerifyTestRun","collisionResult","testNode","omitTestAndReturn","useForceSkipIfInSkipWhen","nodeReorderDetected","newNode","prevNode","reconcilers","currentNode","historyNode","reconcile","nextNode","IsolateInspector","usesKey","Reconciler","handleIsolateNodeWithKey","useHandleTestWithKey","dropNextNodesOnReorder","canReorder","deferThrow","text","TESTS_CALLED_IN_DIFFERENT_ORDER","prevName","undefined","throwTestOrderError","usePickNode","prevTestObject","currentRunTestObject","prevRunTestObject","cancelOverriddenPendingTestOnTestReRun","VestReconciler","reconciler","args","reverse","include","when","INCLUDE_SELF","IsolateTest","input","Error","testFn","useAttemptRunTest","result","currentTest","signal","abortController","error","isUndefined","shouldUseErrorAsMessage","runSyncTest","done","persist","onTestCompleted","rejectionMessage","then","useRunAsyncTest","e","UNEXPECTED_TEST_REGISTRATION_ERROR","JSON","stringify","useRunTest","vestTest","isFunction","fnName","INVALID_PARAM_PASSED_TO_FUNCTION","fn_name","param","expected","validateTestParams","testObjectInput","Bus","useEmit","memo","deps","msg","dependencies","cacheAction","cached","isNull","cachedValue","useSetNextIsolateChild","useGetTestFromCache","Runtime.useSuiteId","useCurrentCursor","wrapTestMemo","getTypedMethods","useOmitOptionalFields","optionalFields","shouldOmit","Set","verifyAndOmit","optionalConfig","add","runOptionalConfig","useInitVestBus","VestBus","useBus","on","RuntimeEvents","ISOLATE_PENDING","ISOLATE_DONE","emit","ASYNC_ISOLATE_DONE","callEach","useRunFieldCallbacks","useRunDoneCallbacks","subscribe","cb","event","off","useSuiteRunResult","freezeAssign","numberEquals","shouldSkipDoneRegistration","useDoneCallback","doneCallback","setFieldCallbacks","setDoneCallbacks","useDeferDoneCallback","createSuite","suiteCallback","SUITE_MUST_BE_INITIALIZED_WITH_FUNCTION","validateSuiteCallback","stateRef","seq","createRef","useCreateVestState","useRunSuiteCallback","mountedStatic","staticSuite","Run","dump","remove","usePrepareEmitter","resume","runStatic","createArgs","Promise","resolve","res","withDump","o","ERROR_OUTSIDE_OF_TEST","WARN_MUST_BE_CALLED_FROM_TEST","list","EACH_CALLBACK_MUST_BE_A_FUNCTION","allowReorder","IsolateEach","arg","index","setMode","HOOK_CALLED_OUTSIDE"],"mappings":"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"}