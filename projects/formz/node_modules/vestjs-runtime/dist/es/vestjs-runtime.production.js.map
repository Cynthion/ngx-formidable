{"version":3,"file":"vestjs-runtime.production.js","sources":["../../src/RuntimeEvents.ts","../../src/errors/ErrorStrings.ts","../../src/Isolate/IsolateInspector.ts","../../src/Isolate/IsolateMutator.ts","../../src/VestRuntime.ts","../../src/Bus.ts","../../src/Isolate/IsolateKeys.ts","../../src/Isolate/IsolateSelectors.ts","../../src/Reconciler.ts","../../src/Isolate/Isolate.ts","../../src/IsolateWalker.ts","../../src/exports/IsolateSerializer.ts"],"sourcesContent":["export const RuntimeEvents = {\n  ASYNC_ISOLATE_DONE: 'ASYNC_ISOLATE_DONE',\n  ISOLATE_DONE: 'ISOLATE_DONE',\n  ISOLATE_ENTER: 'ISOLATE_ENTER',\n  ISOLATE_PENDING: 'ISOLATE_PENDING',\n};\n","export enum ErrorStrings {\n  NO_ACTIVE_ISOLATE = 'Not within an active isolate',\n  UNABLE_TO_PICK_NEXT_ISOLATE = 'Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.',\n  ENCOUNTERED_THE_SAME_KEY_TWICE = `Encountered the same key \"{key}\" twice. This may lead to inconsistent or overriding of results.`,\n  INVALID_ISOLATE_CANNOT_PARSE = `Invalid isolate was passed to IsolateSerializer. Cannot proceed.`,\n}\n","import { Nullable, isNotNullish, isNullish } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\n\nexport class IsolateInspector {\n  static at(isolate: Nullable<TIsolate>, at: number): Nullable<TIsolate> {\n    if (isNullish(isolate)) {\n      return null;\n    }\n    return isolate.children?.[at] ?? null;\n  }\n\n  static cursor(isolate: Nullable<TIsolate>): number {\n    if (isNullish(isolate)) {\n      return 0;\n    }\n    return isolate.children?.length ?? 0;\n  }\n\n  static canReorder<I extends TIsolate>(isolate: Nullable<I>): boolean {\n    if (isNullish(isolate)) {\n      return false;\n    }\n\n    return IsolateInspector.allowsReorder(isolate.parent);\n  }\n\n  static allowsReorder<I extends Record<any, any>>(\n    isolate: Nullable<I>,\n  ): boolean {\n    return isolate?.allowReorder === true;\n  }\n\n  static usesKey(isolate: Nullable<TIsolate>): boolean {\n    if (isNullish(isolate)) {\n      return false;\n    }\n    return isNotNullish(isolate.key);\n  }\n\n  static getChildByKey(\n    isolate: Nullable<TIsolate>,\n    key: string,\n  ): Nullable<TIsolate> {\n    if (isNullish(isolate)) {\n      return null;\n    }\n    return isolate.keys?.[key] ?? null;\n  }\n}\n","import { Nullable, invariant, isNullish } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\n\nexport class IsolateMutator {\n  static setParent(isolate: TIsolate, parent: Nullable<TIsolate>): TIsolate {\n    isolate.parent = parent;\n    return isolate;\n  }\n\n  static saveOutput(isolate: TIsolate, output: any): TIsolate {\n    isolate.output = output;\n    return isolate;\n  }\n\n  static setKey(isolate: TIsolate, key: Nullable<string>): TIsolate {\n    isolate.key = key;\n    return isolate;\n  }\n\n  static addChild(isolate: TIsolate, child: TIsolate): void {\n    invariant(isolate);\n\n    isolate.children = isolate.children ?? [];\n\n    isolate.children.push(child);\n    IsolateMutator.setParent(child, isolate);\n  }\n\n  static removeChild(isolate: TIsolate, node: TIsolate): void {\n    isolate.children =\n      isolate.children?.filter(child => child !== node) ?? null;\n  }\n\n  static addChildKey(isolate: TIsolate, key: string, node: TIsolate): void {\n    invariant(isolate);\n\n    isolate.keys = isolate.keys ?? {};\n\n    isolate.keys[key] = node;\n  }\n\n  static slice(isolate: TIsolate, at: number): void {\n    if (isNullish(isolate.children)) {\n      return;\n    }\n    isolate.children.length = at;\n  }\n\n  static setData(isolate: TIsolate, data: any): void {\n    isolate.data = data;\n  }\n\n  static abort(isolate: TIsolate, reason?: string): void {\n    if (isNullish(isolate.abortController)) {\n      return;\n    }\n    isolate.abortController.abort(reason);\n  }\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport { createCascade } from 'context';\nimport {\n  invariant,\n  deferThrow,\n  isNullish,\n  assign,\n  TinyState,\n  text,\n  optionalFunctionValue,\n  tinyState,\n  BusType,\n  bus,\n  Nullable,\n  DynamicValue,\n} from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\nimport { IsolateInspector } from 'IsolateInspector';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { IRecociler } from 'Reconciler';\n\ntype CTXType = StateRefType & {\n  historyNode: Nullable<TIsolate>;\n  runtimeNode: Nullable<TIsolate>;\n  runtimeRoot: Nullable<TIsolate>;\n  stateRef: StateRefType;\n};\n\nexport type StateRefType = {\n  Bus: BusType;\n  appData: Record<string, any>;\n  historyRoot: TinyState<Nullable<TIsolate>>;\n  Reconciler: IRecociler;\n};\n\nconst PersistedContext = createCascade<CTXType>((stateRef, parentContext) => {\n  if (parentContext) {\n    return null;\n  }\n\n  invariant(stateRef.historyRoot);\n\n  const [historyRootNode] = stateRef.historyRoot();\n\n  const ctxRef = {} as CTXType;\n\n  assign(ctxRef, {\n    historyNode: historyRootNode,\n    runtimeNode: null,\n    runtimeRoot: null,\n    stateRef,\n  });\n\n  return ctxRef;\n});\n\nexport const Run = PersistedContext.run;\n\nexport const RuntimeApi = {\n  Run,\n  createRef,\n  persist,\n  reset,\n  useAvailableRoot,\n  useCurrentCursor,\n  useHistoryRoot,\n  useSetHistoryRoot,\n  useSetNextIsolateChild,\n  useXAppData,\n};\n\nexport function useXAppData<T = object>() {\n  return useX().stateRef.appData as T;\n}\n\nexport function createRef(\n  Reconciler: IRecociler,\n  setter: DynamicValue<Record<string, any>>,\n): StateRefType {\n  return Object.freeze({\n    Bus: bus.createBus(),\n    Reconciler,\n    appData: optionalFunctionValue(setter),\n    historyRoot: tinyState.createTinyState<Nullable<TIsolate>>(null),\n  });\n}\n\nexport function useReconciler() {\n  return useX().stateRef.Reconciler;\n}\n\nexport function persist<T extends (...args: any[]) => any>(cb: T): T {\n  const prev = PersistedContext.useX();\n\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    const ctxToUse = PersistedContext.use() ?? prev;\n    return PersistedContext.run(ctxToUse.stateRef, () => cb(...args));\n  }) as T;\n}\nexport function useX<T = object>(): CTXType & T {\n  return PersistedContext.useX() as CTXType & T;\n}\n\nexport function useHistoryRoot() {\n  return useX().stateRef.historyRoot();\n}\nexport function useHistoryIsolate() {\n  return useX().historyNode;\n}\n\n/**\n * Returns the history isolate at the current position.\n * If there is a parent isolate, it returns the history node from the parent's children.\n * Otherwise, it returns the history node.\n * @returns {Nullable<TIsolate>} The history isolate at the current position.\n */\nexport function useHistoryIsolateAtCurrentPosition() {\n  const parent = useIsolate();\n\n  // This is most likely the historic counterpart of the parent node\n\n  const historyNode = useHistoryIsolate();\n\n  if (parent) {\n    // If we have a parent, we need to get the history node from the parent's children\n    // We take the history node from the cursor of the active node's children\n    return IsolateInspector.at(historyNode, IsolateInspector.cursor(parent));\n  }\n\n  return historyNode;\n}\n\nexport function useSetHistoryRoot(history: TIsolate) {\n  const [, setHistoryRoot] = useHistoryRoot();\n  setHistoryRoot(history);\n}\nexport function useHistoryKey(key?: Nullable<string>): Nullable<TIsolate> {\n  if (isNullish(key)) {\n    return null;\n  }\n\n  const historyNode = useX().historyNode;\n\n  return IsolateInspector.getChildByKey(historyNode, key);\n}\n\nexport function useIsolate() {\n  return useX().runtimeNode ?? null;\n}\nexport function useCurrentCursor() {\n  const isolate = useIsolate();\n  return isolate ? IsolateInspector.cursor(isolate) : 0;\n}\nexport function useRuntimeRoot() {\n  return useX().runtimeRoot;\n}\nexport function useSetNextIsolateChild(child: TIsolate): void {\n  const currentIsolate = useIsolate();\n\n  invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);\n\n  IsolateMutator.addChild(currentIsolate, child);\n  IsolateMutator.setParent(child, currentIsolate);\n}\nexport function useSetIsolateKey(key: Nullable<string>, node: TIsolate): void {\n  if (!key) {\n    return;\n  }\n\n  const currentIsolate = useIsolate();\n\n  invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);\n\n  if (isNullish(IsolateInspector.getChildByKey(currentIsolate, key))) {\n    IsolateMutator.addChildKey(currentIsolate, key, node);\n\n    return;\n  }\n\n  deferThrow(text(ErrorStrings.ENCOUNTERED_THE_SAME_KEY_TWICE, { key }));\n}\nexport function useAvailableRoot<I extends TIsolate = TIsolate>(): I {\n  const root = useRuntimeRoot();\n\n  if (root) {\n    return root as I;\n  }\n\n  const [historyRoot] = useHistoryRoot();\n\n  return historyRoot as I;\n}\n\nexport function reset() {\n  const [, , resetHistoryRoot] = useHistoryRoot();\n\n  resetHistoryRoot();\n}\n","import { isNullish } from 'vest-utils';\n\nimport { persist, useX } from 'VestRuntime';\n\nexport function useBus() {\n  return useX().stateRef.Bus;\n}\n\n/*\n  Returns an emitter, but it also has a shortcut for emitting an event immediately\n  by passing an event name.\n*/\nexport function useEmit(event?: string, data?: any) {\n  const emit = useBus().emit;\n\n  if (!isNullish(event)) {\n    emit(event, data);\n  }\n\n  return persist(emit);\n}\n\nexport function usePrepareEmitter<T = void>(event: string): (arg: T) => void {\n  const emit = useEmit();\n\n  return (arg: T) => emit(event, arg);\n}\n","export enum IsolateKeys {\n  Type = '$type',\n  Keys = 'keys',\n  Key = 'key',\n  Parent = 'parent',\n  Data = 'data',\n  AllowReorder = 'allowReorder',\n  Status = 'status',\n  AbortController = 'abortController',\n  Children = 'children',\n}\n\nexport const ExcludedFromDump = new Set([\n  IsolateKeys.AbortController,\n  IsolateKeys.Parent,\n  IsolateKeys.Keys,\n]);\n","import { Maybe } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\nimport { IsolateKeys } from 'IsolateKeys';\n\nexport function isIsolateType<I extends TIsolate>(\n  node: Maybe<TIsolate>,\n  type: string,\n): node is I {\n  return node?.[IsolateKeys.Type] === type;\n}\n\nexport function isSameIsolateType<A extends TIsolate, B extends TIsolate>(\n  a: A,\n  b: B,\n): boolean {\n  return isIsolateType(a, b[IsolateKeys.Type]);\n}\n\nexport function isSameIsolateIdentity<A extends TIsolate, B extends TIsolate>(\n  a: A,\n  b: B,\n): boolean {\n  return Object.is(a, b) || (isSameIsolateType(a, b) && a.key === b.key);\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport {\n  Maybe,\n  Nullable,\n  invariant,\n  isNullish,\n  optionalFunctionValue,\n} from 'vest-utils';\n\nimport { type TIsolate } from 'Isolate';\nimport { IsolateInspector } from 'IsolateInspector';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { isSameIsolateType } from 'IsolateSelectors';\nimport * as VestRuntime from 'VestRuntime';\n// import { isSameIsolateType } from 'IsolateSelectors';\n\n// I would rather not use `any` here, but instead use `Isolate`.\n// The problem is that it breaks the actual implementation of `Isolate` in `IsolateTest`\n// As it is not properly extending `Isolate`.\nexport interface IRecociler<I = any> {\n  (currentNode: I, historyNode: I): Nullable<I>;\n}\n\nfunction BaseReconciler(\n  currentNode: TIsolate,\n  historyNode: TIsolate,\n): TIsolate {\n  if (isNullish(historyNode)) {\n    return currentNode;\n  }\n  return currentNode;\n}\n\nexport class Reconciler {\n  /**\n   * Reconciles the current isolate with the history isolate.\n   * If the current isolate is of a different type than the history isolate,\n   * the current isolate is returned.\n   * Otherwise, the reconciler function is called to determine the next isolate.\n   * If the reconciler function returns null or undefined, the base reconciler is used.\n   * If no history isolate exists, the current isolate is returned.\n   * @param node The current isolate to reconcile.\n   * @returns The next isolate after reconciliation.\n   */\n  static reconcile(node: TIsolate): TIsolate {\n    const localHistoryNode = VestRuntime.useHistoryIsolateAtCurrentPosition();\n\n    const nextNodeResult = pickNextNode(node, localHistoryNode);\n\n    invariant(nextNodeResult, ErrorStrings.UNABLE_TO_PICK_NEXT_ISOLATE);\n\n    return nextNodeResult;\n  }\n\n  static dropNextNodesOnReorder<I extends TIsolate>(\n    reorderLogic: (newNode: I, prevNode: Maybe<TIsolate>) => boolean,\n    newNode: I,\n    prevNode: Maybe<TIsolate>,\n  ): boolean {\n    const didReorder = reorderLogic(newNode, prevNode);\n\n    if (didReorder) {\n      removeAllNextNodesInIsolate();\n    }\n\n    return didReorder;\n  }\n\n  static handleIsolateNodeWithKey<I extends TIsolate>(\n    node: TIsolate,\n\n    // The revoke function allows the caller to revoke the previous node\n    revoke: ((node: I) => boolean) | false,\n  ): TIsolate {\n    invariant(IsolateInspector.usesKey(node));\n\n    const prevNodeByKey = VestRuntime.useHistoryKey(node.key);\n    let nextNode = node;\n\n    if (\n      !isNullish(prevNodeByKey) &&\n      !optionalFunctionValue(revoke, prevNodeByKey)\n    ) {\n      nextNode = prevNodeByKey;\n    }\n\n    VestRuntime.useSetIsolateKey(node.key, nextNode);\n\n    return nextNode;\n  }\n}\n\nfunction pickNextNode(\n  currentNode: TIsolate,\n  historyNode: Nullable<TIsolate>,\n): TIsolate {\n  if (isNullish(historyNode)) {\n    return handleNoHistoryNode(currentNode);\n  }\n\n  if (!isSameIsolateType(currentNode, historyNode)) {\n    return currentNode;\n  }\n\n  const reconciler = VestRuntime.useReconciler();\n\n  return (\n    reconciler(currentNode, historyNode) ??\n    BaseReconciler(currentNode, historyNode)\n  );\n}\n\nfunction handleNoHistoryNode<I extends TIsolate>(newNode: I): I {\n  if (IsolateInspector.usesKey(newNode)) {\n    return Reconciler.handleIsolateNodeWithKey(newNode, false) as I;\n  }\n\n  return newNode;\n}\n\nfunction removeAllNextNodesInIsolate() {\n  const currentNode = VestRuntime.useIsolate();\n  const historyNode = VestRuntime.useHistoryIsolate();\n\n  if (!historyNode || !currentNode) {\n    // This is probably unreachable, but TS is not convinced.\n    // Let's play it safe.\n    /* istanbul ignore next */\n    return;\n  }\n\n  IsolateMutator.slice(historyNode, IsolateInspector.cursor(currentNode));\n}\n","import { CB, Maybe, Nullable, isNotNullish, isPromise } from 'vest-utils';\n\nimport { useEmit } from 'Bus';\nimport { IsolateKeys } from 'IsolateKeys';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { Reconciler } from 'Reconciler';\nimport { RuntimeEvents } from 'RuntimeEvents';\nimport * as VestRuntime from 'VestRuntime';\n\nexport type IsolateKey = Nullable<string>;\n\nexport type TIsolate<P extends IsolatePayload = IsolatePayload> = {\n  [IsolateKeys.AllowReorder]?: boolean;\n  [IsolateKeys.Parent]: Nullable<TIsolate>;\n  [IsolateKeys.Type]: string;\n  [IsolateKeys.Keys]: Nullable<Record<string, TIsolate>>;\n  [IsolateKeys.Data]: DataOnly<P>;\n  [IsolateKeys.Status]?: string;\n  [IsolateKeys.AbortController]: AbortController;\n  children: Nullable<TIsolate[]>;\n  key: IsolateKey;\n  output: any;\n} & UsedFeaturesOnly<P>;\n\ntype DataOnly<P extends IsolatePayload> = Omit<P, keyof IsolateFeatures>;\ntype UsedFeaturesOnly<P extends IsolatePayload> = Pick<\n  P,\n  keyof IsolateFeatures\n>;\n\nexport class Isolate {\n  // eslint-disable-next-line max-statements\n  static create<Payload extends IsolatePayload>(\n    type: string,\n    callback: CB,\n    payload: Maybe<Payload> = undefined,\n    key?: IsolateKey,\n  ): TIsolate<Payload> {\n    const parent = VestRuntime.useIsolate();\n\n    const newCreatedNode = IsolateMutator.setParent(\n      baseIsolate(type, payload, key),\n      parent,\n    );\n\n    const nextIsolateChild = Reconciler.reconcile(newCreatedNode);\n\n    const localHistoryNode = VestRuntime.useHistoryIsolateAtCurrentPosition();\n\n    const shouldRunNew = Object.is(nextIsolateChild, newCreatedNode);\n\n    if (parent) {\n      // We are within an isolate context. This means that\n      // we need to set the new node to be the child of this parent node.\n      VestRuntime.useSetNextIsolateChild(nextIsolateChild);\n    }\n\n    const output = shouldRunNew\n      ? useRunAsNew(localHistoryNode, newCreatedNode, callback)\n      : nextIsolateChild.output;\n\n    IsolateMutator.saveOutput(nextIsolateChild, output);\n\n    if (!parent) {\n      // We're exiting the node, and there is no parent. This means\n      // that we're at the top level and this node should be set\n      // as the new root of the history tree.\n      VestRuntime.useSetHistoryRoot(nextIsolateChild);\n    }\n\n    return nextIsolateChild as TIsolate<Payload>;\n  }\n\n  static isIsolate(node: any): node is TIsolate {\n    return isNotNullish(node) && node[IsolateKeys.Type];\n  }\n}\n\n/**\n * Creates a new child isolate context where the local history node is the current history node, thus advancing the history cursor.\n * Runs the callback function and returns its output.\n * @param localHistoryNode The local history node.\n * @param current The current isolate.\n * @param callback The callback function to execute.\n * @returns The output of the callback function.\n */\nfunction useRunAsNew<Callback extends CB = CB>(\n  localHistoryNode: Nullable<TIsolate>,\n  current: TIsolate,\n  callback: CB,\n): ReturnType<Callback> {\n  const runtimeRoot = VestRuntime.useRuntimeRoot();\n  const emit = useEmit();\n\n  // We're creating a new child isolate context where the local history node\n  // is the current history node, thus advancing the history cursor.\n  const output = VestRuntime.Run(\n    {\n      historyNode: localHistoryNode,\n      runtimeNode: current,\n      ...(!runtimeRoot && { runtimeRoot: current }),\n    },\n    () => {\n      emit(RuntimeEvents.ISOLATE_ENTER, current);\n      const output = callback(current);\n\n      if (isPromise(output)) {\n        emit(RuntimeEvents.ISOLATE_PENDING, current);\n        output.then(iso => {\n          if (Isolate.isIsolate(iso)) {\n            IsolateMutator.addChild(current, iso);\n          }\n\n          emit(RuntimeEvents.ISOLATE_DONE, current);\n          emit(RuntimeEvents.ASYNC_ISOLATE_DONE, current);\n        });\n      } else {\n        emit(RuntimeEvents.ISOLATE_DONE, current);\n      }\n\n      return output;\n    },\n  );\n\n  current.output = output;\n  return output;\n}\n\nfunction baseIsolate(\n  type: string,\n  payload: Maybe<IsolatePayload> = undefined,\n  key: IsolateKey = null,\n): TIsolate {\n  const { allowReorder, status, ...data } = payload ?? {};\n  return {\n    [IsolateKeys.AllowReorder]: allowReorder,\n    [IsolateKeys.AbortController]: new AbortController(),\n    [IsolateKeys.Keys]: null,\n    [IsolateKeys.Parent]: null,\n    [IsolateKeys.Type]: type,\n    [IsolateKeys.Data]: data as IsolateData,\n    ...(status && { [IsolateKeys.Status]: status }),\n    children: null,\n    key,\n    output: null,\n  };\n}\n\ntype IsolateData = Record<string, any>;\ntype IsolatePayload = IsolateData & IsolateFeatures;\ntype IsolateFeatures = {\n  [IsolateKeys.AllowReorder]?: boolean;\n  [IsolateKeys.Status]?: string;\n};\n","import { CB, Nullable, isNullish, optionalFunctionValue } from 'vest-utils';\n\nimport { type TIsolate } from 'Isolate';\nimport { IsolateMutator } from 'IsolateMutator';\n\ntype VisitOnlyPredicate = (isolate: TIsolate) => boolean;\n\n// eslint-disable-next-line\nexport function walk(\n  startNode: TIsolate,\n  callback: (isolate: TIsolate, breakout: CB<void>) => void,\n  visitOnly?: VisitOnlyPredicate,\n): void {\n  let broke = false;\n\n  // If the breakout function has been called, stop the walk.\n  if (broke) {\n    return;\n  }\n\n  // For each child Isolate object, call the callback function.\n  for (const isolate of startNode.children ?? []) {\n    // Recursively walk through the child Isolate object.\n    walk(\n      isolate,\n      (child, innerBreakout) => {\n        callback(child, () => {\n          innerBreakout();\n          breakout();\n        });\n      },\n      visitOnly,\n    );\n    // If the breakout function has been called, stop the walk.\n    if (broke) {\n      return;\n    }\n  }\n\n  // If visitOnly is not provided or the predicate is satisfied, call the callback function.\n  if (isNullish(visitOnly) || optionalFunctionValue(visitOnly, startNode)) {\n    callback(startNode, breakout);\n  }\n\n  function breakout() {\n    broke = true;\n  }\n}\n\nexport function reduce<T>(\n  startNode: TIsolate,\n  callback: (acc: T, isolate: TIsolate, breakout: CB<void>) => T,\n  initialValue: T,\n  visitOnly?: VisitOnlyPredicate,\n): T {\n  let acc = initialValue;\n\n  walk(\n    startNode,\n    (node, breakout) => {\n      acc = callback(acc, node, breakout);\n    },\n    visitOnly,\n  );\n\n  return acc;\n}\n\n// This function returns true if the given predicate function returns true for any Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function some(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): boolean {\n  let hasMatch = false;\n\n  // Call the walk function with a callback function that sets hasMatch to true if the predicate is satisfied.\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (predicate(node)) {\n        breakout();\n        hasMatch = true;\n      }\n    },\n    visitOnly,\n  );\n\n  return hasMatch;\n}\n\n// This function returns true if the given predicate function returns true for any Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function has(startNode: TIsolate, match: VisitOnlyPredicate): boolean {\n  return some(startNode, () => true, match);\n}\n\n// traverses up to a parent node that satisfies the predicate\n// and returns the first direct descendant that satisfies the predicate\nexport function findClosest<I extends TIsolate = TIsolate>(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): Nullable<I> {\n  let found: Nullable<TIsolate> = null;\n  let current: Nullable<TIsolate> = startNode;\n\n  while (current) {\n    found = current.children?.find(predicate) ?? null;\n\n    if (found) {\n      break;\n    }\n\n    current = current.parent;\n  }\n\n  return found as Nullable<I>;\n}\n\n// This function returns the first Isolate object in the tree that satisfies the given predicate function.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function find(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): Nullable<TIsolate> {\n  let found = null;\n\n  // Call the walk function with a callback function that sets found to the current node if the predicate is satisfied.\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (predicate(node)) {\n        breakout();\n        found = node;\n      }\n    },\n    visitOnly,\n  );\n\n  return found;\n}\n\n// this function acts like find, but returns an array of all matching nodes\nexport function findAll(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): TIsolate[] {\n  const found: TIsolate[] = [];\n\n  walk(\n    startNode,\n    node => {\n      if (predicate(node)) {\n        found.push(node);\n      }\n    },\n    visitOnly,\n  );\n\n  return found;\n}\n\n// This function returns true if the given predicate function returns true for every Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function every(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): boolean {\n  let hasMatch = true;\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (!predicate(node)) {\n        breakout();\n        hasMatch = false;\n      }\n    },\n    visitOnly,\n  );\n\n  return hasMatch;\n}\n\n// This function removes all Isolate objects in the tree that\n// satisfy the given predicate function and have a parent.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function pluck(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): void {\n  walk(\n    startNode,\n    node => {\n      if (predicate(node) && node.parent) {\n        IsolateMutator.removeChild(node.parent, node);\n      }\n    },\n    visitOnly,\n  );\n}\n\n// Returns the closest ancestor Isolate object of the given\n//startNode that satisfies the given predicate function.\nexport function closest(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): Nullable<TIsolate> {\n  let current: Nullable<TIsolate> = startNode;\n  do {\n    if (predicate(current)) {\n      return current;\n    }\n    current = current.parent;\n  } while (current);\n  return null;\n}\n\n// This function returns true if the closest ancestor Isolates of the\n// given startNode that satisfies the given predicate function exists.\nexport function closestExists(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): boolean {\n  return !!closest(startNode, predicate);\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport {\n  Nullable,\n  hasOwnProperty,\n  invariant,\n  isNullish,\n  isStringValue,\n  text,\n} from 'vest-utils';\nimport { expandObject, minifyObject } from 'vest-utils/minifyObject';\n\nimport { TIsolate } from 'Isolate';\nimport { ExcludedFromDump, IsolateKeys } from 'IsolateKeys';\nimport { IsolateMutator } from 'IsolateMutator';\n\nexport class IsolateSerializer {\n  // eslint-disable-next-line max-statements, complexity, max-lines-per-function\n  static deserialize(node: Record<string, any> | TIsolate | string): TIsolate {\n    // Validate the root object\n    const root = (\n      isStringValue(node) ? JSON.parse(node) : ({ ...node } as TIsolate)\n    ) as [any, any];\n\n    const expanded = expandObject(...root);\n\n    IsolateSerializer.validateIsolate(expanded);\n\n    const queue = [expanded];\n\n    // Iterate over the queue until it's empty\n    while (queue.length) {\n      // Get the next item from the queue\n      const current = queue.shift();\n\n      if (!current) {\n        continue;\n      }\n\n      const children = current.children;\n\n      // If there are no children, nothing to do.\n      if (!children) {\n        continue;\n      }\n\n      // Copy the children and set their parent to the current node.\n      current.children = children.map(child => {\n        const nextChild = { ...child };\n\n        IsolateMutator.setParent(nextChild, current);\n        queue.push(nextChild);\n\n        // If the child has a key, add it to the parent's keys.\n        const key = nextChild.key;\n\n        if (key) {\n          current.keys = current.keys ?? {};\n          current.keys[key] = nextChild;\n        }\n\n        return nextChild;\n      });\n    }\n\n    return expanded;\n  }\n\n  static serialize(\n    isolate: Nullable<TIsolate>,\n    replacer: (value: any, key: string) => any,\n  ): string {\n    if (isNullish(isolate)) {\n      return '';\n    }\n\n    const minified = minifyObject(isolate, (value: any, key: string) => {\n      if (ExcludedFromDump.has(key as any)) {\n        return undefined;\n      }\n      return replacer(value, key);\n    });\n\n    return JSON.stringify(minified);\n  }\n\n  static validateIsolate(\n    node: Record<string, any> | TIsolate,\n  ): asserts node is TIsolate {\n    invariant(\n      hasOwnProperty(node, IsolateKeys.Type),\n      text(ErrorStrings.INVALID_ISOLATE_CANNOT_PARSE),\n    );\n  }\n}\n"],"names":["RuntimeEvents","ASYNC_ISOLATE_DONE","ISOLATE_DONE","ISOLATE_ENTER","ISOLATE_PENDING","ErrorStrings","IsolateInspector","at","isolate","isNullish","_b","_a","children","cursor","length","canReorder","allowsReorder","parent","allowReorder","usesKey","isNotNullish","key","getChildByKey","keys","IsolateMutator","setParent","saveOutput","output","setKey","addChild","child","invariant","push","removeChild","node","filter","addChildKey","slice","setData","data","abort","reason","abortController","PersistedContext","createCascade","stateRef","parentContext","historyRoot","historyRootNode","ctxRef","assign","historyNode","runtimeNode","runtimeRoot","Run","run","RuntimeApi","createRef","Reconciler","setter","Object","freeze","Bus","bus","createBus","appData","optionalFunctionValue","tinyState","createTinyState","persist","reset","resetHistoryRoot","useHistoryRoot","useAvailableRoot","root","useRuntimeRoot","useCurrentCursor","useIsolate","useSetHistoryRoot","useSetNextIsolateChild","useXAppData","useX","cb","prev","args","ctxToUse","use","useHistoryIsolate","useHistoryIsolateAtCurrentPosition","history","setHistoryRoot","currentIsolate","NO_ACTIVE_ISOLATE","useBus","useEmit","event","emit","IsolateKeys","arg","ExcludedFromDump","Set","AbortController","Parent","Keys","isIsolateType","type","Type","isSameIsolateType","a","b","is","reconcile","nextNodeResult","currentNode","newNode","handleIsolateNodeWithKey","handleNoHistoryNode","reconciler","BaseReconciler","pickNextNode","VestRuntime.useHistoryIsolateAtCurrentPosition","UNABLE_TO_PICK_NEXT_ISOLATE","dropNextNodesOnReorder","reorderLogic","prevNode","didReorder","VestRuntime.useIsolate","VestRuntime.useHistoryIsolate","removeAllNextNodesInIsolate","revoke","prevNodeByKey","VestRuntime.useHistoryKey","nextNode","deferThrow","text","ENCOUNTERED_THE_SAME_KEY_TWICE","VestRuntime.useSetIsolateKey","Isolate","create","callback","payload","undefined","newCreatedNode","status","__rest","AllowReorder","Data","Status","baseIsolate","nextIsolateChild","localHistoryNode","shouldRunNew","VestRuntime.useSetNextIsolateChild","current","VestRuntime.useRuntimeRoot","VestRuntime.Run","isPromise","then","iso","isIsolate","useRunAsNew","VestRuntime.useSetHistoryRoot","walk","startNode","visitOnly","broke","innerBreakout","breakout","some","predicate","hasMatch","closest","found","find","match","initialValue","acc","IsolateSerializer","deserialize","isStringValue","JSON","parse","expanded","expandObject","validateIsolate","queue","shift","map","nextChild","serialize","replacer","minified","minifyObject","value","has","stringify","hasOwnProperty","INVALID_ISOLATE_CANNOT_PARSE"],"mappings":"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"}