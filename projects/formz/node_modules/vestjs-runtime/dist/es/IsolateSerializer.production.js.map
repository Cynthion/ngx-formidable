{"version":3,"file":"IsolateSerializer.production.js","sources":["../../src/errors/ErrorStrings.ts","../../src/Isolate/IsolateKeys.ts","../../src/Isolate/IsolateMutator.ts","../../src/exports/IsolateSerializer.ts"],"sourcesContent":["export enum ErrorStrings {\n  NO_ACTIVE_ISOLATE = 'Not within an active isolate',\n  UNABLE_TO_PICK_NEXT_ISOLATE = 'Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.',\n  ENCOUNTERED_THE_SAME_KEY_TWICE = `Encountered the same key \"{key}\" twice. This may lead to inconsistent or overriding of results.`,\n  INVALID_ISOLATE_CANNOT_PARSE = `Invalid isolate was passed to IsolateSerializer. Cannot proceed.`,\n}\n","export enum IsolateKeys {\n  Type = '$type',\n  Keys = 'keys',\n  Key = 'key',\n  Parent = 'parent',\n  Data = 'data',\n  AllowReorder = 'allowReorder',\n  Status = 'status',\n  AbortController = 'abortController',\n  Children = 'children',\n}\n\nexport const ExcludedFromDump = new Set([\n  IsolateKeys.AbortController,\n  IsolateKeys.Parent,\n  IsolateKeys.Keys,\n]);\n","import { Nullable, invariant, isNullish } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\n\nexport class IsolateMutator {\n  static setParent(isolate: TIsolate, parent: Nullable<TIsolate>): TIsolate {\n    isolate.parent = parent;\n    return isolate;\n  }\n\n  static saveOutput(isolate: TIsolate, output: any): TIsolate {\n    isolate.output = output;\n    return isolate;\n  }\n\n  static setKey(isolate: TIsolate, key: Nullable<string>): TIsolate {\n    isolate.key = key;\n    return isolate;\n  }\n\n  static addChild(isolate: TIsolate, child: TIsolate): void {\n    invariant(isolate);\n\n    isolate.children = isolate.children ?? [];\n\n    isolate.children.push(child);\n    IsolateMutator.setParent(child, isolate);\n  }\n\n  static removeChild(isolate: TIsolate, node: TIsolate): void {\n    isolate.children =\n      isolate.children?.filter(child => child !== node) ?? null;\n  }\n\n  static addChildKey(isolate: TIsolate, key: string, node: TIsolate): void {\n    invariant(isolate);\n\n    isolate.keys = isolate.keys ?? {};\n\n    isolate.keys[key] = node;\n  }\n\n  static slice(isolate: TIsolate, at: number): void {\n    if (isNullish(isolate.children)) {\n      return;\n    }\n    isolate.children.length = at;\n  }\n\n  static setData(isolate: TIsolate, data: any): void {\n    isolate.data = data;\n  }\n\n  static abort(isolate: TIsolate, reason?: string): void {\n    if (isNullish(isolate.abortController)) {\n      return;\n    }\n    isolate.abortController.abort(reason);\n  }\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport {\n  Nullable,\n  hasOwnProperty,\n  invariant,\n  isNullish,\n  isStringValue,\n  text,\n} from 'vest-utils';\nimport { expandObject, minifyObject } from 'vest-utils/minifyObject';\n\nimport { TIsolate } from 'Isolate';\nimport { ExcludedFromDump, IsolateKeys } from 'IsolateKeys';\nimport { IsolateMutator } from 'IsolateMutator';\n\nexport class IsolateSerializer {\n  // eslint-disable-next-line max-statements, complexity, max-lines-per-function\n  static deserialize(node: Record<string, any> | TIsolate | string): TIsolate {\n    // Validate the root object\n    const root = (\n      isStringValue(node) ? JSON.parse(node) : ({ ...node } as TIsolate)\n    ) as [any, any];\n\n    const expanded = expandObject(...root);\n\n    IsolateSerializer.validateIsolate(expanded);\n\n    const queue = [expanded];\n\n    // Iterate over the queue until it's empty\n    while (queue.length) {\n      // Get the next item from the queue\n      const current = queue.shift();\n\n      if (!current) {\n        continue;\n      }\n\n      const children = current.children;\n\n      // If there are no children, nothing to do.\n      if (!children) {\n        continue;\n      }\n\n      // Copy the children and set their parent to the current node.\n      current.children = children.map(child => {\n        const nextChild = { ...child };\n\n        IsolateMutator.setParent(nextChild, current);\n        queue.push(nextChild);\n\n        // If the child has a key, add it to the parent's keys.\n        const key = nextChild.key;\n\n        if (key) {\n          current.keys = current.keys ?? {};\n          current.keys[key] = nextChild;\n        }\n\n        return nextChild;\n      });\n    }\n\n    return expanded;\n  }\n\n  static serialize(\n    isolate: Nullable<TIsolate>,\n    replacer: (value: any, key: string) => any,\n  ): string {\n    if (isNullish(isolate)) {\n      return '';\n    }\n\n    const minified = minifyObject(isolate, (value: any, key: string) => {\n      if (ExcludedFromDump.has(key as any)) {\n        return undefined;\n      }\n      return replacer(value, key);\n    });\n\n    return JSON.stringify(minified);\n  }\n\n  static validateIsolate(\n    node: Record<string, any> | TIsolate,\n  ): asserts node is TIsolate {\n    invariant(\n      hasOwnProperty(node, IsolateKeys.Type),\n      text(ErrorStrings.INVALID_ISOLATE_CANNOT_PARSE),\n    );\n  }\n}\n"],"names":["ErrorStrings","IsolateKeys","ExcludedFromDump","Set","AbortController","Parent","Keys","IsolateMutator","setParent","isolate","parent","saveOutput","output","setKey","key","addChild","child","invariant","children","_a","push","removeChild","node","_b","filter","addChildKey","keys","slice","at","isNullish","length","setData","data","abort","reason","abortController","IsolateSerializer","deserialize","root","isStringValue","JSON","parse","Object","assign","expanded","expandObject","validateIsolate","queue","current","shift","map","nextChild","serialize","replacer","minified","minifyObject","value","has","stringify","hasOwnProperty","Type","text","INVALID_ISOLATE_CANNOT_PARSE"],"mappings":"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"}